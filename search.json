[{"title":"LRU","url":"/2023/10/24/LRU/","content":"LRU缓存实现type LRUCache struct &#123;\tcapacity int\tlength   int\tll       *list.List\trecord   map[int]*list.Element&#125;type kv struct &#123;\tkey   int\tvalue int&#125;func Constructor(capacity int) LRUCache &#123;\treturn LRUCache&#123;\t\tcapacity: capacity,\t\tlength:   0,\t\tll:       list.New(),\t\trecord:   make(map[int]*list.Element),\t&#125;&#125;func (this *LRUCache) Get(key int) int &#123;\tif e, ok := this.record[key]; ok &#123;\t\tthis.ll.MoveToFront(e)\t\treturn e.Value.(*kv).value\t&#125; else &#123;\t\treturn -1\t&#125;&#125;func (this *LRUCache) Put(key int, value int) &#123;\tif e, ok := this.record[key]; ok &#123;\t\tthis.ll.Remove(e)\t\tdelete(this.record, e.Value.(*kv).key)\t\tthis.length--\t&#125;\tfor this.length == this.capacity &#123;\t\trem := this.ll.Back()\t\tthis.ll.Remove(rem)\t\tdelete(this.record, rem.Value.(*kv).key)\t\tthis.length--\t&#125;\tnew := this.ll.PushFront(&amp;kv&#123;key, value&#125;)\tthis.record[key] = new\tthis.length++\treturn&#125;\n\ntype LRUCache struct &#123;\tcapacity int\tlength   int\tll       *List\trecord   map[int]*LNode&#125;type List struct &#123;\thead, tail *LNode&#125;type LNode struct &#123;\tPre, Next  *LNode\tkey, value int&#125;func Constructor(capacity int) LRUCache &#123;\thead := &amp;LNode&#123;&#125;\ttail := &amp;LNode&#123;Pre: head&#125;\thead.Next = tail\treturn LRUCache&#123;\t\tcapacity: capacity,\t\tlength:   0,\t\tll:       &amp;List&#123;head: head, tail: tail&#125;,\t\trecord:   make(map[int]*LNode),\t&#125;&#125;func (this *LRUCache) Get(key int) int &#123;\tif node, ok := this.record[key]; ok &#123;\t\tthis.moveToHead(node)\t\treturn node.value\t&#125;\treturn -1&#125;func (this *LRUCache) Put(key int, value int) &#123;\tif node, ok := this.record[key]; ok &#123;\t\tnode.value = value\t\tthis.moveToHead(node)\t\treturn\t&#125;\tif this.length == this.capacity &#123;\t\trem := this.removeTail()\t\tdelete(this.record, rem.key)\t\tthis.length--\t&#125;\tnode := &amp;LNode&#123;key: key, value: value&#125;\tthis.addNodeToHead(node)\tthis.record[key] = node\tthis.length++\treturn&#125;func (this *LRUCache) addNodeToHead(node *LNode) &#123;\tnode.Next = this.ll.head.Next\tnode.Pre = this.ll.head\tnode.Next.Pre = node\tthis.ll.head.Next = node&#125;func (this *LRUCache) moveToHead(node *LNode) &#123;\tthis.removeNode(node)\tthis.addNodeToHead(node)&#125;func (this *LRUCache) removeTail() *LNode &#123;\treturn this.removeNode(this.ll.tail.Pre)&#125;func (this *LRUCache) removeNode(node *LNode) *LNode &#123;\tnode.Pre.Next = node.Next\tnode.Next.Pre = node.Pre\treturn node&#125;\n","categories":["算法"],"tags":["算法"]},{"title":"Linux命令","url":"/2023/10/22/Linux%E5%91%BD%E4%BB%A4/","content":"1.ls-l  文件详细信息-i  inode文件号-R  递归打印子目录下文件-d  不打印子目录下文件-h  以容易理解的方式打印文件大小-t  按修改时间排序输出-r  按相反顺序排序输出-a  所有文件-A  同-a，但不包括.和..-F  目录文件名后加/，可执行文件后加*\n2.cdcd - 返回上一个目录\n3.mkdir-v  创建时显示详细信息-p  递归创建目录mkdir -m 777 test   创建时设置目录权限\n4.cat-n  行号-b  省略空行cat &gt; log.txt &lt;&lt; EOF   使用heredoc来创建文件\n5.more-n  总行数+n  从第n行开始显示\n6.head-n  前n行-c  前c个字节\n7.tail-n  后n行 \n8.whichwhich 待搜索可执行文件名\n9.findfind 搜索路径 搜索条件-name 名称，可用正则表达式-perm 权限-type 类型-exec 对搜索结果的后续处理，结果用&#123;&#125;占位，如find . -type f -exec ls -l &#123;&#125; \\;与xargs结合使用，如find . -type f | xargs -I &#123;&#125; ls -l &#123;&#125; -maxdepth n 查询最大层数为n\n10.dfdf -h 磁盘使用情况\n11.du-c  查询结果总和-h  更可读\n12.topus      用户控件CPU占用百分比si      软中断CPU百分比\n","categories":["Linux"],"tags":["Linux命令"]},{"title":"MySQL表设计","url":"/2023/10/22/MySQL%E8%A1%A8%E8%AE%BE%E8%AE%A1/","content":"1. 范式与反范式1.1 数据库三范式\n1NF：原子性，列不可分2NF：满足1NF，同时列属性完全依赖于主键，不能部分依赖于主键3NF：满足2NF，同时列属性不传递依赖于非主属性，只能直接依赖于主键\n\n举例：设计符合2NF表\n\n原始表中订单编号和商品编号为联合主键，商品名称、单位、价格等信息不于主键相关，只与商品编号相关，违反了2NF,因此将原表拆分成3张表\n\n范式优点\n避免数据冗余，减少维护数据完整性的麻烦减少数据库空间数据变更速度快\n\n范式缺点\n按照范式的规范设计的表，等级越高的范式设计出来的表数量越多获取数据时，表关联过多，性能较差\n\n1.2 反范式\n针对业务场景，为减少多表关联，提高业务响应时间，允许适当的数据冗余。\n\n反范式优点\n允许适当的数据冗余，业务场景中需要的数据几乎都可以在一张表上显示，避免关联可以设计有效的索引\n\n2. 使用基本原则\n\n只用于数据存储，不进行复杂数据运算，不承载业务逻辑，确保存储和计算分离\n查询数据时尽量使用单表查询，减少跨库查询和多表关联\n杜绝大事务、大字段等性能杀手 · 大事务：运行步骤较多，涉及表和字段较多，容易造成资源争抢甚至形成死锁。事务回滚时会导致资源占用时间过长 · 大字段：blob、text等大字段尽量少使用或选择与主业务表分离，减少对该类字段的检索和更新\n\n\n3. 基本设置规则\n默认指定存储引擎为InnoDB默认字符集为UTF8mb4，支持emoji等特殊字符\n\n","categories":["MySQL"],"tags":["MySQL"]},{"title":"Linux文本处理","url":"/2023/10/23/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/","content":"1. grep:使用正则表达式匹配文本，适用于单纯查找匹配文本1.1 基本格式grep [option] [pattern] [filename]\n1.2 参数\n-A&lt;行数x&gt;     除了显示符合样式的行之外，还显示该行之后x行-B&lt;行数x&gt;     除了显示符合样式的行之外，还显示该行之前x行-C&lt;行数x&gt;     除了显示符合样式的行之外，还显示该行前后x行-c           统计匹配的行数-e           实现多个选项间的逻辑or关系-E           扩展的正则表达式-v           显示不被pattern匹配的行\n\n2. sed:利用脚本处理文本文件,但不修改文件，适用于编辑匹配到的文本2.1 基本格式sed [-e&lt;script&gt;][-f&lt;script file&gt;][filename]\n2.2 参数\n-e        指定script处理文本文件，多个-e可以执行多次匹配-f        指定script文件处理文本文件-n        仅显示处理后结果-i        将结果保存到文件，或可以用重定向 &gt;savefilename\n\n2.3 动作说明\na     匹配行后追加c     替换d     删除i     匹配行前插入p     打印s     替换\n\n2.4 举例2.4.1 在第三行后追加newline这行字符sed -e 3a\\newline filename\n2.4.2 在匹配Linux字符串的行后追加sed -e /Linux/a\\newline filename\n2.4.3 删除匹配Linux的行sed -e /Linux/d filename\n2.4.4 替换匹配Linux的行为Macsed -e /Linux/c\\Mac filenamesed s/Linux/Mac/g filename\n2.4.5 仅打印匹配Linux行sed -ne /Linux/p filename\n3. awk:格式化文本，对文本进行较复杂格式处理3.1 基本格式awk [action] [filename]\n3.2 参数\n-F 指定分隔符，如 awk -F ‘:’ ‘{ print $1 }’ demo.txt，输出第一个字段\n\n3.3 变量$0          当前行$1          第一个字段$NF         NF表示字段数，$NF表示最后一个字段$(NF-1)     倒数第二个字段NR          当前处理行号FILENAME    当前文件名\n3.4 简单条件awk &#x27;条件 动作&#x27; 文件名\n3.5 复杂条件，if语句awk &#x27;&#123;if条件&#125; 动作; else 动作&#x27; 文件名\n3.5.1 针对测试数据获取访问量前3的ip地址测试数据：128.233.172.181  view1136.233.172.182  view1128.234.172.181  view2128.233.172.183  view1136.233.172.182  view1128.238.172.181  view3128.233.172.181  view1预期输出：2 136.233.172.1822 128.233.172.1811 128.238.172.181命令:awk &#x27;&#123;print $1&#125;&#x27; test.log | sort | uniq -c | sort -rn -k 1 | head -n 3","categories":["Linux"],"tags":["Linux命令"]},{"title":"IO多路复用","url":"/2023/10/20/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/","content":"select执行原理\n\n将当前进程的所有文件描述符（使用bitmap存储），一次性的从用户态拷贝到内核态\n在内核中快速地无差别遍历每个fd，判断是否有数据到达\n将所有fd状态，从内核态拷贝到内核态，并返回已就绪的fd个数\n在用户态遍历判断具体哪个fd已就绪，然后进行相应的事件处理\n\n\n存在的不足\n\n文件描述符为bitmap，有长度限制（1024）\nfdset无法做到重用，每次循环必须重新创建\n频繁的用户态和内核态拷贝，性能开销大\n需要对文件描述符进行遍历，时间复杂度O(n)\n\n\npollpoll结构体struct pollfd &#123;    int fd;         //文件描述符    short events;   //注册事件    short revents;  //实际发生事件，由内核填充&#125;\n执行原理\n\n将当前进程的所有文件描述符（socket连接），一次性从用户态拷贝到内核态\n在内核中快速地无差别遍历每个fd，判断是否有数据到达\n将所有fd状态，从内核态拷贝到用户态，并返回已就绪fd个数\n在用户态遍历具体哪个fd已就绪，进行对应事件处理\n\n\n存在的不足\n\npoll模型采用pollfd结构数组，解决了select的1024个文件描述符限制\n依然存在频繁的用户态和内核态间的拷贝，性能开销大\n时间复杂度为O(n)\n\n\nepoll执行原理\neventpoll结构体\n\nstruct eventpill&#123;    rdylist     已就绪事件队列    rbr         红黑树，存储文件描述符    wq          阻塞进程等待队列&#125;\n\n\nepoll_create创建eventpoll\nepoll_ctl创建epitem结构体，将包含文件描述符的epitem加入eventpoll的rbr红黑树，阻塞进程加入wq阻塞队列\nepoll_wait阻塞进程，将其加入阻塞队列\n当有数据到达时，调用回调方法，将文件描述符加入到就绪队列，并判断是否是阻塞队列进程所等待的事件\n执行后续事件\n\n\n优势\n\n在epoll_ctl()函数中，为每个文件描述符都指定回调函数，基于回调函数把就绪事件放到就绪队列中，时间复杂度降为O(1)\n只需要在epoll_ctl()时传递一次文件描述符，epoll_wait()时不需要再次传递文件描述符\nepoll基于红黑树+双链表存储，没有最大连接数限制\n\n\n","categories":["操作系统"],"tags":["IO多路复用"]},{"title":"WebSocket","url":"/2023/10/23/WebSocket/","content":"\n主要针对服务器主动推送消息给客户端的场景。例如在扫码登陆这种简单场景下，HTTP1.1可采用不断轮询或长轮询的方式解决。但是在需要主动交互的全双工场景下，上述两种方式由于开销较大所以不适用，因此需要WebSocket。\n\n介绍\nWebSocket基于TCP协议，同一时间内客户端和服务器双方都可以主动向对方发送数据，即全双工通信。\n\n建立连接\n浏览器在TCP三次握手建立连接后，统一使用HTTP协议先进行一次通信。请求建立WebSocket连接的特殊请求头如下，Sec-WebSocket-Key字段是随机生成的一段 base64码：\n\nConnection: UpgradeUpgrade: WebSocketSec-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg==\\r\\n\n\n服务器响应结果如下,其中状态码101表示协议切换：\n\nHTTP/1.1 101 Switching Protocols\\r\\nSec-WebSocket-Accept: iBJKv/ALIW2DobfoA4dmr3JHBCY=\\r\\nUpgrade: WebSocket\\r\\nConnection: Upgrade\\r\\n\n\n\n服务器在收到请求后，会使用某公开算法将请求头中的Sec-WebSocket-Key转换为另一段字符串，即Sec-WebSocket-Accept。客户端收到响应后同样使用相同的公开算法进行字符串转换并比对，如果一致则通过。经过以上一来一回两次HTTP握手完成WebSocket建立。\n\n\n消息格式\noption字段\n等于1，表示text(string)类型数据包\n等于2，表示二进制类型([]byte)数据包\n等于8，表示关闭连接信号\n\npayload字段\n存放实际传输的数据长度，单位是字节，可解决TCP粘包问题。\n\n\n最开始7bit值是0～125，则表示全部数据长度，长度在0～125之间\n最开始7bit值为126，则需要额外读取7bit后16bit，即长度在126～65535之间\n最开始7bit长度为127，则需要额外读取7bit后64bit，即长度大于65535\n\npayload data字段\n实际传输的数据\n\n适用场景\n 适用于需要服务器和客户端（浏览器）频繁交互的大部分场景，比如网页&#x2F;小程序游戏，网页聊天室，以及一些类似飞书这样的网页协同办公软件。\n\n","categories":["计算机网络"],"tags":["WebSocket","HTTP"]},{"title":"markdown","url":"/2023/10/20/markdown/","content":"hexo new page 新文件夹hexo new post 新文件\n1.粗体**粗体**\n2.斜体*斜体*\n3.块引用&gt; 段落块一&gt; 段落块二&gt; 段落块三\n4.有序列表1. 列表项一2. 列表向二    1. 子列表项一    2. 子列表向二\n5.无序列表- 列表项一- 列表项二    - 子列表项一    - 子列表项二\n6.代码块```code```\n7.图片![测试图片加载失败描述](/2023/10/20/markdown/test.png &quot;测试图片&quot;)\n8.分隔线***\n9.链接这是一个链接 [链接名称](链接url)\n10.转义字符\\需转义字符","categories":["markdown"],"tags":["markdown"]},{"title":"top","url":"/2023/10/31/top/","content":"1. top结果详解\n第一行，系统整体信息\n\n\n系统当前时间\n系统运行时间    \n当前登陆用户数  \n系统负载(平均队列长度)，三个数值依次表示1min，5min，15min前到现在的平均值\n\n\n第二行，进程信息\n\ntotal:    进程总数running:    正在运行的进程数sleeping:     睡眠进程数stopped:      停止的进程数zombie:       僵尸进程数\n\n第三行，CPU信息\n\nus:   用户空间占用CPU百分比sy:   内核空间占用CPU百分比ni:   用户进程空间内改变过优先级的进程占用CPU百分比id:   空闲CPU百分比wa:   等待输入输出的CPU百分比hi:   硬中断占用CPU百分比si:   软中断占用CPU百分比st:   (Steal time) 是当 hypervisor 服务另一个虚拟处理器的时候，虚拟 CPU 等待实际 CPU 的时间的百分比。\n\n第四行，内存信息\n\ntotal:    物理内存总量free:     空闲内存总量used:     使用的物理内存总量buff&#x2F;cache: 用作内核缓存的内存量\n\n第五行，交换区信息\n记录已存在内存中的交换区数据大小；内存中的内容被换出到交换区，而后又被换入内存，但使用过的交换区未被覆盖，相应的内存再次被换出时不需要再次写入。total:    交换区总量free:     空闲交换区总量used:     使用的交换区总量avail Mem:    缓冲的交换区总量\n\n进程信息区\n默认显示PID、USER、PR、NI、VIRT、RES、SHR、S、%CPU、%MEM、TIME+、COMMAND\n\nPID:进程IDPPID:父进程IDUID:进程所有者用户IDUSER:进程所有者用户名PR:进程优先级NI:nice值，负值表示高优先级，正值表示低优先级%CPU:上次更新到现在的CPU时间占用百分比TIME+:进程使用的CPU总时间%MEM:进程使用的物理内存百分比CODE:可执行代码占用物理内存的大小，单位kbDATA:可执行代码以外的部分(数据段和栈)占用的物理内存大小，单位kbRES:进程正在使用的、未被换出的物理内存大小，单位kb，RES=CODE+DATASWAP:进程使用的虚拟内存中，被换出的大小，单位kbVIRT:进程使用的虚拟内存总量，单位kb，VIRT=SWAP+RESSHR:共享内存大小，单位kbnFLT:页面错误次数nDRT:最后一次写入到现在，被修改过页面数量S:进程状态COMMAND:运行进程的命令\n2. 可用选项\n-d 后跟秒数，表示指定两次刷新的时间间隔-p 后跟进程PID，查询指定进程信息-b 批处理，输出内容到文件时需要-n 指定刷新次数\n\n举例：每2.5秒刷新一次top内容，总计5次，并将结束输出到top.txt文件top -b -d 2.5 -n 5 &gt; top.txt\n\nP:对%CPU列排序M:对%MEM列排序T:对TIME+列排序R:逆序\n\n\nf:显示或隐藏列\n\n","categories":["Linux"],"tags":["Linux命令","top命令详解"]},{"title":"排序","url":"/2023/10/23/%E6%8E%92%E5%BA%8F/","content":"快速排序(不稳定)func QuickSort(nums []int, l, r int) &#123;\tif l &gt;= r &#123;\t\treturn\t&#125;\tmid := Partition(nums, l, r)\tQuickSort(nums, l, mid-1)\tQuickSort(nums, mid+1, r)&#125;func Partition(nums []int, l, r int) int &#123;\tindex := rand.Intn(r-l+1) + l\tnums[l], nums[index] = nums[index], nums[l]\tfor l &lt; r &#123;\t\tfor l &lt; r &amp;&amp; nums[l] &lt; nums[r] &#123;\t\t\tr--\t\t&#125;\t\tif l &lt; r &#123;\t\t\tnums[l], nums[r] = nums[r], nums[l]\t\t\tl++\t\t&#125;\t\tfor l &lt; r &amp;&amp; nums[l] &lt; nums[r] &#123;\t\t\tl++\t\t&#125;\t\tif l &lt; r &#123;\t\t\tnums[l], nums[r] = nums[r], nums[l]\t\t\tr--\t\t&#125;\t&#125;\treturn l&#125;\n归并排序(稳定)func sortArray(nums []int) []int &#123;\tif len(nums) &lt; 2 &#123;\t\treturn nums\t&#125;\tmid := len(nums) / 2\tleft := nums[:mid]\tright := nums[mid:]\treturn merge(sortArray(left), sortArray(right))&#125;func merge(left, right []int) []int &#123;\tvar res []int\tfor len(left) &gt; 0 &amp;&amp; len(right) &gt; 0 &#123;\t\tif left[0] &lt; right[0] &#123;\t\t\tres = append(res, left[0])\t\t\tleft = left[1:]\t\t&#125; else &#123;\t\t\tres = append(res, right[0])\t\t\tright = right[1:]\t\t&#125;\t&#125;\tif len(left) &gt; 0 &#123;\t\tres = append(res, left...)\t&#125;\tif len(right) &gt; 0 &#123;\t\tres = append(res, right...)\t&#125;\treturn res&#125;","categories":["算法"],"tags":["算法","排序"]},{"title":"操作系统八股","url":"/2023/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A1/","content":"1. 用户态和内核态1.1 介绍\n\n用户态：用户态运行的程序可以直接去读用户程序的数据，拥有的权限较低。当应用程序需要执行某些特殊权限操作时，如磁盘IO、网络通信等，需要向操作系统发起系统调用请求，进入内核态。\n内核态：内核态运行的进程可以访问计算机的任何资源，包括内存空间、设备、驱动程序等，拥有较高的权限。操作系统接收到进程的系统调用请求时，会从用户态切换到内核态，执行响应的系统调用，将结果返回给用户态进程后，会从内核态切换回用户态。\n\n\n1.2 区分用户态和内核态的好处\n\n提高系统安全性，如果所有进程都能执行特权指令可能会严重影响系统运行。\n如果只有一个内核态，所有进程共享系统资源，将会导致大量的系统资源竞争和冲突，降低系统运行性能。\n\n\n1.3 切换方式\n\n系统调用(Trap):用户进程主动切换到内核态的一种方式，如磁盘IO读写，核心机制是通过一个中断实现用户态到内核态的转换，执行结束返回时再次通过中断回到用户态。\n中断:外部设备执行完相关操作后，向CPU发出中断信号，如果此时先前执行的指令是用户态指令，则需要进行切换。\n异常:如缺页异常，与中断的区别是中断来自外部，异常来自于先前执行指令的问题。\n\n\n2. 进程和线程2.1 介绍\n\n进程：程序运行的实力，系统资源分配的最小单位\n线程：轻量级进程，系统调度的基本单位。占有资源包括自身的程序计数器和本地方法栈等。\n协程：用户级线程，切换时不需要切换到内核态\n\n\n2.1.1 线程相比于进程的优势\n\n线程切换成本低，且切换时不需要切换关键的TLB\n线程更轻量，一个进程可创建多个线程，实现并发处理任务\n同一个进程内的线程可以共享内存和文件，不需要调用内核切换\n\n\n2.1.2 协程相比于线程的优势\n\n占用资源相较于线程更少\n切换时不需要陷入内核态\n\n\n2.2 进程的状态\n创建，就绪，运行，阻塞,结束\n\n2.3 进程间通信方式\n共享内存，socket套接字，管道，有名管道，共享内存，消息队列\n\n2.4 进程调度算法\n先来先服务，短作业优先，时间片轮询，多级反馈队列，优先级调度\n\n3. 死锁3.1 死锁产生的必要条件\n互斥，非抢占，不可剥夺，循环等待\n\n3.2 死锁预防\n破坏必要条件之一\n\n3.3 死锁避免\n银行家算法\n\n3.4 死锁检测\n进程资源状态图\n\n4. 内存管理虚拟内存的作用\n隔离进程，提高安全性提高内存利用率，逻辑上扩充内存空间简化内存管理，程序员不需要直接操作物理内存\n\n非连续内存管理\n段式管理：根据段号查段表，找到实际其实物理地址，加上段内偏移页式管理：根据页号查页表，找到实际其实物理地址，加上段内偏移段页式管理：先取段地址，然后页地址\n\n5. 软硬连接\n\n硬连接(ln)：硬连接和源文件inode节点号相同，删了源文件还能查看，由于inode节点号每个文件系统唯一，所以硬连接不能跨文件系统。\n软连接(ln -s)：类似快捷方式，存的是源文件路径，删了源文件无法查看。\n\n\n","categories":["操作系统"],"tags":["操作系统"]}]