[{"title":"Linux命令","url":"/2023/10/22/Linux%E5%91%BD%E4%BB%A4/","content":"1.ls-l  文件详细信息-i  inode文件号-R  递归打印子目录下文件-d  不打印子目录下文件-h  以容易理解的方式打印文件大小-t  按修改时间排序输出-r  按相反顺序排序输出-a  所有文件-A  同-a，但不包括.和..-F  目录文件名后加/，可执行文件后加*\n2.cdcd - 返回上一个目录\n3.mkdir-v  创建时显示详细信息-p  递归创建目录mkdir -m 777 test   创建时设置目录权限\n4.cat-n  行号-b  省略空行cat &gt; log.txt &lt;&lt; EOF   使用heredoc来创建文件\n5.more-n  总行数+n  从第n行开始显示\n6.head-n  前n行-c  前c个字节\n7.tail-n  后n行 \n8.whichwhich 待搜索可执行文件名\n9.findfind 搜索路径 搜索条件-name 名称，可用正则表达式-perm 权限-type 类型-exec 对搜索结果的后续处理，结果用&#123;&#125;占位，如find . -type f -exec ls -l &#123;&#125; \\;与xargs结合使用，如find . -type f | xargs -I &#123;&#125; ls -l &#123;&#125; -maxdepth n 查询最大层数为n\n10.dfdf -h 磁盘使用情况\n11.du-c  查询结果总和-h  更可读\n","categories":["Linux"],"tags":["Linux命令"]},{"title":"Linux文本处理","url":"/2023/10/23/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/","content":"1. grep:使用正则表达式匹配文本，适用于单纯查找匹配文本1.1 基本格式grep [option] [pattern] [filename]\n1.2 参数\n-A&lt;行数x&gt;     除了显示符合样式的行之外，还显示该行之后x行-B&lt;行数x&gt;     除了显示符合样式的行之外，还显示该行之前x行-C&lt;行数x&gt;     除了显示符合样式的行之外，还显示该行前后x行-c           统计匹配的行数-e           实现多个选项间的逻辑or关系-E           扩展的正则表达式-v           显示不被pattern匹配的行\n\n2. sed:利用脚本处理文本文件,但不修改文件，适用于编辑匹配到的文本2.1 基本格式sed [-e&lt;script&gt;][-f&lt;script file&gt;][filename]\n2.2 参数\n-e        指定script处理文本文件，多个-e可以执行多次匹配-f        指定script文件处理文本文件-n        仅显示处理后结果-i        将结果保存到文件，或可以用重定向 &gt;savefilename\n\n2.3 动作说明\na     匹配行后追加c     替换d     删除i     匹配行前插入p     打印s     替换\n\n2.4 举例2.4.1 在第三行后追加newline这行字符sed -e 3a\\newline filename\n2.4.2 在匹配Linux字符串的行后追加sed -e /Linux/a\\newline filename\n2.4.3 删除匹配Linux的行sed -e /Linux/d filename\n2.4.4 替换匹配Linux的行为Macsed -e /Linux/c\\Mac filenamesed s/Linux/Mac/g filename\n2.4.5 仅打印匹配Linux行sed -ne /Linux/p filename\n3. awk:格式化文本，对文本进行较复杂格式处理3.1 基本格式awk [action] [filename]\n3.2 参数\n-F 指定分隔符，如 awk -F ‘:’ ‘{ print $1 }’ demo.txt，输出第一个字段\n\n3.3 变量$0          当前行$1          第一个字段$NF         NF表示字段数，$NF表示最后一个字段$(NF-1)     倒数第二个字段NR          当前处理行号FILENAME    当前文件名\n3.4 简单条件awk &#x27;条件 动作&#x27; 文件名\n3.5 复杂条件，if语句awk &#x27;&#123;if条件&#125; 动作; else 动作&#x27; 文件名\n3.5.1 针对测试数据获取访问量前3的ip地址测试数据：128.233.172.181  view1136.233.172.182  view1128.234.172.181  view2128.233.172.183  view1136.233.172.182  view1128.238.172.181  view3128.233.172.181  view1预期输出：2 136.233.172.1822 128.233.172.1811 128.238.172.181命令:awk &#x27;&#123;print $1&#125;&#x27; test.log | sort | uniq -c | sort -rn -k 1 | head -n 3","categories":["Linux"],"tags":["Linux命令"]},{"title":"WebSocket","url":"/2023/10/23/WebSocket/","content":"\n主要针对服务器主动推送消息给客户端的场景。例如在扫码登陆这种简单场景下，HTTP1.1可采用不断轮询或长轮询的方式解决。但是在需要主动交互的全双工场景下，上述两种方式由于开销较大所以不适用，因此需要WebSocket。\n\n介绍\nWebSocket基于TCP协议，同一时间内客户端和服务器双方都可以主动向对方发送数据，即全双工通信。\n\n建立连接\n浏览器在TCP三次握手建立连接后，统一使用HTTP协议先进行一次通信。请求建立WebSocket连接的特殊请求头如下，Sec-WebSocket-Key字段是随机生成的一段 base64码：\n\nConnection: UpgradeUpgrade: WebSocketSec-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg==\\r\\n\n\n服务器响应结果如下,其中状态码101表示协议切换：\n\nHTTP/1.1 101 Switching Protocols\\r\\nSec-WebSocket-Accept: iBJKv/ALIW2DobfoA4dmr3JHBCY=\\r\\nUpgrade: WebSocket\\r\\nConnection: Upgrade\\r\\n\n\n\n服务器在收到请求后，会使用某公开算法将请求头中的Sec-WebSocket-Key转换为另一段字符串，即Sec-WebSocket-Accept。客户端收到响应后同样使用相同的公开算法进行字符串转换并比对，如果一致则通过。经过以上一来一回两次HTTP握手完成WebSocket建立。\n\n\n消息格式\noption字段\n等于1，表示text(string)类型数据包\n等于2，表示二进制类型([]byte)数据包\n等于8，表示关闭连接信号\n\npayload字段\n存放实际传输的数据长度，单位是字节，可解决TCP粘包问题。\n\n\n最开始7bit值是0～125，则表示全部数据长度，长度在0～125之间\n最开始7bit值为126，则需要额外读取7bit后16bit，即长度在126～65535之间\n最开始7bit长度为127，则需要额外读取7bit后64bit，即长度大于65535\n\npayload data字段\n实际传输的数据\n\n适用场景\n 适用于需要服务器和客户端（浏览器）频繁交互的大部分场景，比如网页&#x2F;小程序游戏，网页聊天室，以及一些类似飞书这样的网页协同办公软件。\n\n","categories":["计算机网络"],"tags":["WebSocket","HTTP"]},{"title":"MySQL表设计","url":"/2023/10/22/MySQL%E8%A1%A8%E8%AE%BE%E8%AE%A1/","content":"1. 范式与反范式1.1 数据库三范式\n1NF：原子性，列不可分2NF：满足1NF，同时列属性完全依赖于主键，不能部分依赖于主键3NF：满足2NF，同时列属性不传递依赖于非主属性，只能直接依赖于主键\n\n举例：设计符合2NF表\n\n原始表中订单编号和商品编号为联合主键，商品名称、单位、价格等信息不于主键相关，只与商品编号相关，违反了2NF,因此将原表拆分成3张表\n\n范式优点\n避免数据冗余，减少维护数据完整性的麻烦减少数据库空间数据变更速度快\n\n范式缺点\n按照范式的规范设计的表，等级越高的范式设计出来的表数量越多获取数据时，表关联过多，性能较差\n\n1.2 反范式\n针对业务场景，为减少多表关联，提高业务响应时间，允许适当的数据冗余。\n\n反范式优点\n允许适当的数据冗余，业务场景中需要的数据几乎都可以在一张表上显示，避免关联可以设计有效的索引\n\n2. 使用基本原则\n\n只用于数据存储，不进行复杂数据运算，不承载业务逻辑，确保存储和计算分离\n查询数据时尽量使用单表查询，减少跨库查询和多表关联\n杜绝大事务、大字段等性能杀手 · 大事务：运行步骤较多，涉及表和字段较多，容易造成资源争抢甚至形成死锁。事务回滚时会导致资源占用时间过长 · 大字段：blob、text等大字段尽量少使用或选择与主业务表分离，减少对该类字段的检索和更新\n\n\n3. 基本设置规则\n默认指定存储引擎为InnoDB默认字符集为UTF8mb4，支持emoji等特殊字符\n\n","categories":["MySQL"],"tags":["MySQL"]},{"title":"markdown","url":"/2023/10/20/markdown/","content":"hexo new page 新文件夹hexo new post 新文件\n1.粗体**粗体**\n2.斜体*斜体*\n3.块引用&gt; 段落块一&gt; 段落块二&gt; 段落块三\n4.有序列表1. 列表项一2. 列表向二    1. 子列表项一    2. 子列表向二\n5.无序列表- 列表项一- 列表项二    - 子列表项一    - 子列表项二\n6.代码块```code```\n7.图片![测试图片加载失败描述](/2023/10/20/markdown/test.png &quot;测试图片&quot;)\n8.分隔线***\n9.链接这是一个链接 [链接名称](链接url)\n10.转义字符\\需转义字符","categories":["markdown"],"tags":["markdown"]},{"title":"排序","url":"/2023/10/23/%E6%8E%92%E5%BA%8F/","content":"快速排序(不稳定)func QuickSort(nums []int, l, r int) &#123;\tif l &gt;= r &#123;\t\treturn\t&#125;\tmid := Partition(nums, l, r)\tQuickSort(nums, l, mid-1)\tQuickSort(nums, mid+1, r)&#125;func Partition(nums []int, l, r int) int &#123;\tindex := rand.Intn(r-l+1) + l\tnums[l], nums[index] = nums[index], nums[l]\tfor l &lt; r &#123;\t\tfor l &lt; r &amp;&amp; nums[l] &lt; nums[r] &#123;\t\t\tr--\t\t&#125;\t\tif l &lt; r &#123;\t\t\tnums[l], nums[r] = nums[r], nums[l]\t\t\tl++\t\t&#125;\t\tfor l &lt; r &amp;&amp; nums[l] &lt; nums[r] &#123;\t\t\tl++\t\t&#125;\t\tif l &lt; r &#123;\t\t\tnums[l], nums[r] = nums[r], nums[l]\t\t\tr--\t\t&#125;\t&#125;\treturn l&#125;\n归并排序(稳定)func sortArray(nums []int) []int &#123;\tif len(nums) &lt; 2 &#123;\t\treturn nums\t&#125;\tmid := len(nums) / 2\tleft := nums[:mid]\tright := nums[mid:]\treturn merge(sortArray(left), sortArray(right))&#125;func merge(left, right []int) []int &#123;\tvar res []int\tfor len(left) &gt; 0 &amp;&amp; len(right) &gt; 0 &#123;\t\tif left[0] &lt; right[0] &#123;\t\t\tres = append(res, left[0])\t\t\tleft = left[1:]\t\t&#125; else &#123;\t\t\tres = append(res, right[0])\t\t\tright = right[1:]\t\t&#125;\t&#125;\tif len(left) &gt; 0 &#123;\t\tres = append(res, left...)\t&#125;\tif len(right) &gt; 0 &#123;\t\tres = append(res, right...)\t&#125;\treturn res&#125;","categories":["算法"],"tags":["算法","排序"]},{"title":"IO多路复用","url":"/2023/10/20/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/","content":"select执行原理\n\n将当前进程的所有文件描述符（使用bitmap存储），一次性的从用户态拷贝到内核态\n在内核中快速地无差别遍历每个fd，判断是否有数据到达\n将所有fd状态，从内核态拷贝到内核态，并返回已就绪的fd个数\n在用户态遍历判断具体哪个fd已就绪，然后进行相应的事件处理\n\n\n存在的不足\n\n文件描述符为bitmap，有长度限制（1024）\nfdset无法做到重用，每次循环必须重新创建\n频繁的用户态和内核态拷贝，性能开销大\n需要对文件描述符进行遍历，时间复杂度O(n)\n\n\npollpoll结构体struct pollfd &#123;    int fd;         //文件描述符    short events;   //注册事件    short revents;  //实际发生事件，由内核填充&#125;\n执行原理\n\n将当前进程的所有文件描述符，一次性从用户态拷贝到内核态\n在内核中快速地无差别遍历每个fd，判断是否有数据到达\n将所有fd状态，从内核态拷贝到用户态，并返回已就绪fd个数\n在用户态遍历具体哪个fd已就绪，进行对应事件处理\n\n\n存在的不足\n\npoll模型采用pollfd结构数组，解决了select的1024个文件描述符限制\n依然存在频繁的用户态和内核态间的拷贝，性能开销大\n时间复杂度为O(n)\n\n\n","categories":["操作系统"],"tags":["IO多路复用"]}]