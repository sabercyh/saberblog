[{"title":"CAP理论","url":"/2023/11/26/CAP%E7%90%86%E8%AE%BA/","content":"CAP理论\nCAP理论是分布式系统设计中经常被提及的理论，分别对应Consistency（一致性）、Availability（可用性）、Partition tolerance（分区容错性）；在分布式系统中，正常运行时三者均可满足，当出现分区故障时三者不能同时满足，最多只能满足其中两个。\n\n1. 一致性（Consistency）\n一致性是指在分布式系统中，数据在多个副本之间是否能够保持一致的特性\n\n\n假设分布式存储系统中有两个节点，经过一次写请求后，两个节点的数据都发生了变化，且后续的读请求均可以在这两个节点上返回相同的数据。那么，这两个节点的数据就被认为是一致的。\n\n\n\n若一致性写入失败，意味着后续读请求可能出现读取到旧数据的情况，为保证对外数据一致性，于是选择不返回任何数据。\n\n\n2. 可用性（Availability）\n可用性是指在分布式系统中的节点接收到请求后都要能处理并响应结果。需要同时满足以下两点：\n\n\n返回结果必须在合理的时间以内，如果超过业务定的时间，则认为系统不满足可用性\n系统能正常接收请求的所有节点收到请求后都需要返回结果，如果个别节点宕机，其他节点依然能正常接收处理请求，则认为系统依然可用。如果节点内部存在数据不一致问题，依然需要返回数据，即使返回结果可能不合理。\n\n3. 分区容忍性（Partition tolerance）\n分区容忍性是指分布式系统中，当网络出现分区故障时，分布式系统仍然需要继续运行，即使出现网络分区，也能继续提供服务。\n\n\nCAP选择\n在分布式系统中，P是必须的，即使出现分区错误，分布式系统依然需要可用。而根据一致性和可用性选择的不同，分布式系统通常被分为CP系统和AP系统。\n\n\n\n对CP系统，当出现分区故障时，客户端的任何请求都会卡死或超时，系统的每个节点都会返回一致的数据，典型的系统如Zookeeper\n对AP系统，当出现分区故障时，客户端依然可以访问系统，获取的数据有新有旧，典型的系统如Eureka\n\n\nCAP注意点\n\n当没有出现分区问题时，分布式系统应该同时保持一致性和可用性\nC和A是针对分布式系统中的局部模块，而不是整体。比如在支付系统中，订单流水应该保持强一致性，应选择C;会员名称等就不需要强一致性，可以选择A\nCAP本身没有考虑网络延迟问题，它认为一致性是立即生效的，但是要保持一致性实际上是需要时间成本的，因此往往分布式系统多选用AP\nC和A并不是二选一的问题，而是重要性的区别。在强调一致性的同时，并不代表可用性完全被抛弃。比如Zookeeper只是在master出问题的时候才可能出现几十秒的不可用状态，大多是时间都是在强调一致性的同时保证可用性。又或者在其他更强调可用性的系统中，也会采用一些技术手段保证数据的最终一致性\n\n\n","categories":["CAP理论"],"tags":["分布式系统理论"]},{"title":"Linux文本处理","url":"/2023/10/23/Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/","content":"1. grep:使用正则表达式匹配文本，适用于单纯查找匹配文本1.1 基本格式grep [option] [pattern] [filename]\n1.2 参数\n-A&lt;行数x&gt;     除了显示符合样式的行之外，还显示该行之后x行-B&lt;行数x&gt;     除了显示符合样式的行之外，还显示该行之前x行-C&lt;行数x&gt;     除了显示符合样式的行之外，还显示该行前后x行-c           统计匹配的行数-e           实现多个选项间的逻辑or关系-E           扩展的正则表达式-v           显示不被pattern匹配的行\n\n2. sed:利用脚本处理文本文件,但不修改文件，适用于编辑匹配到的文本2.1 基本格式sed [-e&lt;script&gt;][-f&lt;script file&gt;][filename]\n2.2 参数\n-e        指定script处理文本文件，多个-e可以执行多次匹配-f        指定script文件处理文本文件-n        仅显示处理后结果-i        将结果保存到文件，或可以用重定向 &gt;savefilename\n\n2.3 动作说明\na     匹配行后追加c     替换d     删除i     匹配行前插入p     打印s     替换\n\n2.4 举例2.4.1 在第三行后追加newline这行字符sed -e 3a\\newline filename\n2.4.2 在匹配Linux字符串的行后追加sed -e /Linux/a\\newline filename\n2.4.3 删除匹配Linux的行sed -e /Linux/d filename\n2.4.4 替换匹配Linux的行为Macsed -e /Linux/c\\Mac filenamesed s/Linux/Mac/g filename\n2.4.5 仅打印匹配Linux行sed -ne /Linux/p filename\n3. awk:格式化文本，对文本进行较复杂格式处理3.1 基本格式awk [action] [filename]\n3.2 参数\n-F 指定分隔符，如 awk -F ‘:’ ‘{ print $1 }’ demo.txt，输出第一个字段\n\n3.3 变量$0          当前行$1          第一个字段$NF         NF表示字段数，$NF表示最后一个字段$(NF-1)     倒数第二个字段NR          当前处理行号FILENAME    当前文件名\n3.4 简单条件awk &#x27;条件 动作&#x27; 文件名\n3.5 复杂条件，if语句awk &#x27;&#123;if条件&#125; 动作; else 动作&#x27; 文件名\n3.5.1 针对测试数据获取访问量前3的ip地址测试数据：128.233.172.181  view1136.233.172.182  view1128.234.172.181  view2128.233.172.183  view1136.233.172.182  view1128.238.172.181  view3128.233.172.181  view1预期输出：2 136.233.172.1822 128.233.172.1811 128.238.172.181命令:awk &#x27;&#123;print $1&#125;&#x27; test.log | sort | uniq -c | sort -rn -k 1 | head -n 3","categories":["Linux"],"tags":["Linux命令"]},{"title":"LRU","url":"/2023/10/24/LRU/","content":"LRU缓存实现type LRUCache struct &#123;\tcapacity int\tlength   int\tll       *list.List\trecord   map[int]*list.Element&#125;type kv struct &#123;\tkey   int\tvalue int&#125;func Constructor(capacity int) LRUCache &#123;\treturn LRUCache&#123;\t\tcapacity: capacity,\t\tlength:   0,\t\tll:       list.New(),\t\trecord:   make(map[int]*list.Element),\t&#125;&#125;func (this *LRUCache) Get(key int) int &#123;\tif e, ok := this.record[key]; ok &#123;\t\tthis.ll.MoveToFront(e)\t\treturn e.Value.(*kv).value\t&#125; else &#123;\t\treturn -1\t&#125;&#125;func (this *LRUCache) Put(key int, value int) &#123;\tif e, ok := this.record[key]; ok &#123;\t\tthis.ll.Remove(e)\t\tdelete(this.record, e.Value.(*kv).key)\t\tthis.length--\t&#125;\tfor this.length == this.capacity &#123;\t\trem := this.ll.Back()\t\tthis.ll.Remove(rem)\t\tdelete(this.record, rem.Value.(*kv).key)\t\tthis.length--\t&#125;\tnew := this.ll.PushFront(&amp;kv&#123;key, value&#125;)\tthis.record[key] = new\tthis.length++\treturn&#125;\n\ntype LRUCache struct &#123;\tcapacity int\tlength   int\tll       *List\trecord   map[int]*LNode&#125;type List struct &#123;\thead, tail *LNode&#125;type LNode struct &#123;\tPre, Next  *LNode\tkey, value int&#125;func Constructor(capacity int) LRUCache &#123;\thead := &amp;LNode&#123;&#125;\ttail := &amp;LNode&#123;Pre: head&#125;\thead.Next = tail\treturn LRUCache&#123;\t\tcapacity: capacity,\t\tlength:   0,\t\tll:       &amp;List&#123;head: head, tail: tail&#125;,\t\trecord:   make(map[int]*LNode),\t&#125;&#125;func (this *LRUCache) Get(key int) int &#123;\tif node, ok := this.record[key]; ok &#123;\t\tthis.moveToHead(node)\t\treturn node.value\t&#125;\treturn -1&#125;func (this *LRUCache) Put(key int, value int) &#123;\tif node, ok := this.record[key]; ok &#123;\t\tnode.value = value\t\tthis.moveToHead(node)\t\treturn\t&#125;\tif this.length == this.capacity &#123;\t\trem := this.removeTail()\t\tdelete(this.record, rem.key)\t\tthis.length--\t&#125;\tnode := &amp;LNode&#123;key: key, value: value&#125;\tthis.addNodeToHead(node)\tthis.record[key] = node\tthis.length++\treturn&#125;func (this *LRUCache) addNodeToHead(node *LNode) &#123;\tnode.Next = this.ll.head.Next\tnode.Pre = this.ll.head\tnode.Next.Pre = node\tthis.ll.head.Next = node&#125;func (this *LRUCache) moveToHead(node *LNode) &#123;\tthis.removeNode(node)\tthis.addNodeToHead(node)&#125;func (this *LRUCache) removeTail() *LNode &#123;\treturn this.removeNode(this.ll.tail.Pre)&#125;func (this *LRUCache) removeNode(node *LNode) *LNode &#123;\tnode.Pre.Next = node.Next\tnode.Next.Pre = node.Pre\treturn node&#125;\n","categories":["算法"],"tags":["算法"]},{"title":"RabbitMQ","url":"/2023/11/16/RabbitMQ/","content":"架构设计\nPublisher: 消息的生产者\nCounsumer: 消息的消费者\nExchange: 交换器，接受生产者发送的消息，并根据路由规则转发到指定的队列中\nBrocker: 消息队列服务器实体\nVirtual Host: 虚拟主机，一个broker里可以开设多个vhost，对vhost进行隔离\nQueue: 消息队列载体，每个消息都会被投入到一个特定的queue中\nBinding: 绑定，用于消息队列和交换器之间的关联\nChannel: 信道，在客户端的每个连接里，可以建立多个channel，每个channel代表一个会话任务，多个channel可以服用同一条TCP连接\nConnection: TCP连接\nMessage: 消息，由Header和body组成，header中包含routing-key（路由键）、priority（优先级）、delivery-mode\n\n六种工作模式1. 简单模式\n生产者将消息发送到队列中，消息的消费者监听队列，并从队列中取出消息，消息被消费后，从队列中删除\n\n目录结构：\n提前设置vhost为mq，并在其下添加quene名为singlemq；\n//singlemq.gopackage singlemqimport (\t&quot;log&quot;\t&quot;github.com/streadway/amqp&quot;)// single 模式// 定义 RabbitMQ 的数据结构  type RabbitMQ struct &#123;\tconn      *amqp.Connection // 连接\tchannel   *amqp.Channel    // 通道\tQueueName string           // 队列名\tExchange  string           // 交换机\tKey       string           // 路由键\tMQUrl     string           // MQ的虚拟机地址 &#125;  // New 一个 RabbitMQ func NewRabbitMQ(rbt *RabbitMQ) &#123;\tif rbt == nil || rbt.QueueName == &quot;&quot;  || rbt.MQUrl == &quot;&quot; &#123;\t   log.Panic(&quot;please check QueueName,MQUrl ...&quot;)\t&#125; \tconn, err := amqp.Dial(rbt.MQUrl)\tif err != nil &#123;\t   log.Panicf(&quot;amqp.Dial error : %v&quot;, err)\t&#125;\trbt.conn = conn \tchannel, err := rbt.conn.Channel()\tif err != nil &#123;\t   log.Panicf(&quot;rbt.conn.Channel error : %v&quot;, err)\t&#125;\trbt.channel = channel &#125;   func RabbitMQFree(rbt *RabbitMQ)&#123;\tif rbt == nil&#123;\t   log.Printf(&quot;rbt is nil,free failed&quot;)\t   return\t&#125;\trbt.channel.Close()\trbt.conn.Close() &#125; func (rbt *RabbitMQ) Init() &#123;\t// 申请队列\t_, err := rbt.channel.QueueDeclare(\t   rbt.QueueName, // 队列名\t   true,          // 是否持久化\t   false,         // 是否自动删除\t   false,         // 是否排他\t   false,         // 是否阻塞\t   nil,           // 其他参数\t)\tif err != nil &#123;\t   log.Printf(&quot;rbt.channel.QueueDeclare error : %v&quot;, err)\t   return\t&#125; &#125;   // 生产消息  func (rbt *RabbitMQ) Produce(data []byte) &#123; \t// 向队列中加入数据\terr := rbt.channel.Publish(\t   rbt.Exchange,        // 交换机\t   rbt.QueueName,       // 队列名\t   false,    // 若为true，根据自身exchange类型和routekey规则无法找到符合条件的队列会把消息返还给发送者\t   false,    // 若为true，当exchange发送消息到队列后发现队列上没有消费者，则会把消息返还给发送者\t   amqp.Publishing&#123;\t\t  ContentType: &quot;text/plain&quot;,\t\t  Body:        data,\t   &#125;,\t)\tif err != nil &#123;\t   log.Printf(&quot;rbt.channel.Publish error : %v&quot;, err)\t   return\t&#125;\treturn &#125;  // 消费消息 func (rbt *RabbitMQ) Consume() &#123; \t// 消费数据\tmsg, err := rbt.channel.Consume(\t   rbt.QueueName,    // 队列名\t   &quot;consumerName&quot;,    // 消费者的名字\t   true,     // 是否自动应答\t   false,    // 是否排他\t   false,    // 若为true，表示不能将同一个Conenction中生产者发送的消息传递给这个Connection中的消费者\t   false,    // 是否阻塞\t   nil,         // 其他属性\t) \tif err != nil &#123;\t   log.Printf(&quot;rbt.channel.Consume error : %v&quot;, err)\t   return\t&#125; \tfor data := range msg &#123;\t   log.Printf(&quot;received data is %v&quot;, string(data.Body))\t&#125;  &#125; \n//consumer.go   package mainimport (\t&quot;log&quot;\t&quot;rabbitmq/singlemq&quot;)func main() &#123;\tlog.SetFlags(log.Llongfile | log.Ltime | log.Ldate)\trbt := &amp;singlemq.RabbitMQ&#123;\t\tQueueName: &quot;singlemq&quot;,\t\tMQUrl:     &quot;amqp://guest:guest@127.0.0.1:5672/mq&quot;,\t&#125;\tsinglemq.NewRabbitMQ(rbt)\trbt.Consume()&#125;\n//main.gopackage mainimport (\t&quot;fmt&quot;\t&quot;log&quot;\t&quot;time&quot;\t&quot;rabbitmq/singlemq&quot;)/*RabbimtMQ single 模式 案例应用场景：简单消息队列的使用，一个生产者一个消费者生产消息*/func main() &#123;\t// 设置日志\tlog.SetFlags(log.Llongfile | log.Ltime | log.Ldate)\trbt := &amp;singlemq.RabbitMQ&#123;\t\tQueueName: &quot;singlemq&quot;,\t\tMQUrl:     &quot;amqp://guest:guest@127.0.0.1:5672/mq&quot;,\t&#125;\tsinglemq.NewRabbitMQ(rbt)\tvar index = 0\tfor &#123;\t\t// 生产消息\t\trbt.Produce([]byte(fmt.Sprintf(&quot;hello wolrd %d &quot;, index)))\t\tlog.Println(&quot;发送成功 &quot;, index)\t\tindex++\t\ttime.Sleep(1 * time.Second)\t&#125;&#125;\n\n\n2. work模式\n当生产者生产消息的速度大过消费者消费消息的速度时，消息队列会堆积很多消息，此时需要使用work模式，可以提高处理速度。生产者将消息放入队列，消息的消费者可以有多个，队列通过轮询的方式向消费者分发消息。消息竞争获取，为保证同一个消息不被重复消费，需要设置syncronize，保证一条消息只能被一个消费者消费。场景举例：秒杀系统、红包场景work模式实现与single模式类似，只是比single模式多了一些消费者，代码实现同上，额外开启一个终端执行consumer.go\n\n目录结构：\n提前设置vhost为mq，并在其下添加quene名为workmq；启动时类似single模式，并多启动一个consumer\n// workmq.gopackage workmqimport (\t&quot;log&quot;\t&quot;github.com/streadway/amqp&quot;)// work 模式// 定义 RabbitMQ 的数据结构type RabbitMQ struct &#123;\tconn      *amqp.Connection // 连接\tchannel   *amqp.Channel    // 通道\tQueueName string           // 队列名\tExchange  string           // 交换机\tKey       string           // 路由键\tMQUrl     string           // MQ的虚拟机地址&#125;// New 一个 RabbitMQfunc NewRabbitMQ(rbt *RabbitMQ) &#123;\tif rbt == nil || rbt.QueueName == &quot;&quot; || rbt.MQUrl == &quot;&quot; &#123;\t\tlog.Panic(&quot;please check QueueName,MQUrl ...&quot;)\t&#125;\tconn, err := amqp.Dial(rbt.MQUrl)\tif err != nil &#123;\t\tlog.Panicf(&quot;amqp.Dial error : %v&quot;, err)\t&#125;\trbt.conn = conn\tchannel, err := rbt.conn.Channel()\tif err != nil &#123;\t\tlog.Panicf(&quot;rbt.conn.Channel error : %v&quot;, err)\t&#125;\trbt.channel = channel&#125;func RabbitMQFree(rbt *RabbitMQ) &#123;\tif rbt == nil &#123;\t\tlog.Printf(&quot;rbt is nil,free failed&quot;)\t\treturn\t&#125;\trbt.channel.Close()\trbt.conn.Close()&#125;func (rbt *RabbitMQ) Init() &#123;\t// 申请队列\t_, err := rbt.channel.QueueDeclare(\t\trbt.QueueName, // 队列名\t\ttrue,          // 是否持久化\t\tfalse,         // 是否自动删除\t\tfalse,         // 是否排他\t\tfalse,         // 是否阻塞\t\tnil,           // 其他参数\t)\tif err != nil &#123;\t\tlog.Printf(&quot;rbt.channel.QueueDeclare error : %v&quot;, err)\t\treturn\t&#125;&#125;// 生产消息func (rbt *RabbitMQ) Produce(data []byte) &#123;\t// 向队列中加入数据\terr := rbt.channel.Publish(\t\trbt.Exchange,  // 交换机\t\trbt.QueueName, // 队列名\t\tfalse,         // 若为true，根据自身exchange类型和routekey规则无法找到符合条件的队列会把消息返还给发送者\t\tfalse,         // 若为true，当exchange发送消息到队列后发现队列上没有消费者，则会把消息返还给发送者\t\tamqp.Publishing&#123;\t\t\tContentType: &quot;text/plain&quot;,\t\t\tBody:        data,\t\t&#125;,\t)\tif err != nil &#123;\t\tlog.Printf(&quot;rbt.channel.Publish error : %v&quot;, err)\t\treturn\t&#125;\treturn&#125;// 消费消息func (rbt *RabbitMQ) Consume() &#123;\t// 消费数据\tmsg, err := rbt.channel.Consume(\t\trbt.QueueName,  // 队列名\t\t&quot;consumerName&quot;, // 消费者的名字\t\ttrue,           // 是否自动应答\t\tfalse,          // 是否排他\t\tfalse,          // 若为true，表示不能将同一个Conenction中生产者发送的消息传递给这个Connection中的消费者\t\tfalse,          // 是否阻塞\t\tnil,            // 其他属性\t)\tif err != nil &#123;\t\tlog.Printf(&quot;rbt.channel.Consume error : %v&quot;, err)\t\treturn\t&#125;\tfor data := range msg &#123;\t\tlog.Printf(&quot;received data is %v&quot;, string(data.Body))\t&#125;&#125;\n\n// main.gopackage mainimport (\t&quot;fmt&quot;\t&quot;log&quot;\t&quot;time&quot;\t&quot;rabbitmq/workmq&quot;)/*RabbimtMQ work 模式 案例应用场景：work 模式的使用，一个生产者多个消费者生产消息*/func main() &#123;\t// 设置日志\tlog.SetFlags(log.Llongfile | log.Ltime | log.Ldate)\trbt := &amp;workmq.RabbitMQ&#123;\t\tQueueName: &quot;workmq&quot;,\t\tMQUrl:     &quot;amqp://guest:guest@127.0.0.1:5672/mq&quot;,\t&#125;\tworkmq.NewRabbitMQ(rbt)\tvar index = 0\tfor &#123;\t\t// 生产消息\t\trbt.Produce([]byte(fmt.Sprintf(&quot;hello wolrd %d &quot;, index)))\t\tlog.Println(&quot;发送成功 &quot;, index)\t\tindex++\t\ttime.Sleep(1 * time.Second)\t&#125;&#125;\n\n// consumer.gopackage mainimport (\t&quot;log&quot;\t&quot;rabbitmq/workmq&quot;)func main() &#123;\tlog.SetFlags(log.Llongfile | log.Ltime | log.Ldate)\trbt := &amp;workmq.RabbitMQ&#123;\t\tQueueName: &quot;workmq&quot;,\t\tMQUrl:     &quot;amqp://guest:guest@127.0.0.1:5672/mq&quot;,\t&#125;\tworkmq.NewRabbitMQ(rbt)\trbt.Consume()&#125;\n3. publish&#x2F;subscribe 发布订阅模式\n生产者将消息发送到交换机，交换机将消息转发给绑定该交换机的队列，消费者监听自己的队列，并从队列中取出消息。场景举例：邮件群发，微信公众号\n\n目录结构：\n提前设置vhost为mq，并在其下添加交换机名为PubEx，类型为fanout；consumer绑定监听队列到指定交换机\n// pubsubmq.gopackage pubsubmqimport (\t&quot;log&quot;\t&quot;github.com/streadway/amqp&quot;)// publish 模式// 定义 RabbitMQ 的数据结构// go get github.com/streadway/amqptype RabbitMQ struct &#123;\tconn      *amqp.Connection // 连接\tchannel   *amqp.Channel    // 通道\tQueueName string           // 队列名\tExchange  string           // 交换机\tKey       string           // 路由键\tMQUrl     string           // MQ的虚拟机地址&#125;// New 一个 RabbitMQfunc NewRabbitMQ(rbt *RabbitMQ) &#123;\tif rbt == nil || rbt.Exchange == &quot;&quot; || rbt.MQUrl == &quot;&quot; &#123;\t\tlog.Panic(&quot;please check Exchange,MQUrl ...&quot;)\t&#125;\tconn, err := amqp.Dial(rbt.MQUrl)\tif err != nil &#123;\t\tlog.Panicf(&quot;amqp.Dial error : %v&quot;, err)\t&#125;\trbt.conn = conn\tchannel, err := rbt.conn.Channel()\tif err != nil &#123;\t\tlog.Panicf(&quot;rbt.conn.Channel error : %v&quot;, err)\t&#125;\trbt.channel = channel&#125;func RabbitMQFree(rbt *RabbitMQ) &#123;\tif rbt == nil &#123;\t\tlog.Print(&quot;rbt is nil,free failed&quot;)\t\treturn\t&#125;\trbt.channel.Close()\trbt.conn.Close()&#125;func (rbt *RabbitMQ) Init() &#123;\t// 1、创建交换机\terr := rbt.channel.ExchangeDeclare(\t\trbt.Exchange,        // 交换机\t\tamqp.ExchangeFanout, // 交换机类型\t\ttrue,                // 是否持久化\t\tfalse,               // 是否自动删除\t\tfalse,               // true表示这个exchange不可以被client用来推送消息，仅用来进行exchange和exchange之间的绑定\t\tfalse,               // 是否阻塞\t\tnil,                 // 其他属性\t)\tif err != nil &#123;\t\tlog.Printf(&quot;rbt.channel.ExchangeDeclare error : %v&quot;, err)\t\treturn\t&#125;&#125;// 生产消息 publishfunc (rbt *RabbitMQ) PublishMsg(data []byte) &#123;\t// 1、向队列中加入数据\terr := rbt.channel.Publish(\t\trbt.Exchange, // 交换机\t\t&quot;&quot;,           // 队列名\t\tfalse,        // 若为true，根据自身exchange类型和routekey规则无法找到符合条件的队列会把消息返还给发送者\t\tfalse,        // 若为true，当exchange发送消息到队列后发现队列上没有消费者，则会把消息返还给发送者\t\tamqp.Publishing&#123;\t\t\tContentType: &quot;text/plain&quot;,\t\t\tBody:        data,\t\t&#125;,\t)\tif err != nil &#123;\t\tlog.Printf(&quot;rbt.channel.Publish error : %v&quot;, err)\t\treturn\t&#125;\treturn&#125;// 消费消息func (rbt *RabbitMQ) SubscribeMsg() &#123;\t// 1、创建队列\tq, err := rbt.channel.QueueDeclare(\t\t&quot;&quot;, // 此处我们传入的是空，则是随机产生队列的名称\t\ttrue,\t\tfalse,\t\tfalse,\t\tfalse,\t\tnil,\t)\tif err != nil &#123;\t\tlog.Printf(&quot;rbt.channel.QueueDeclare error : %v&quot;, err)\t\treturn\t&#125;\t// 2、绑定队列\terr = rbt.channel.QueueBind(\t\tq.Name,       // 队列名字\t\t&quot;&quot;,           // 在publish模式下，这里key 为空\t\trbt.Exchange, // 交换机名称\t\tfalse,        // 是否阻塞\t\tnil,          // 其他属性\t)\tif err != nil &#123;\t\tlog.Printf(&quot;rbt.channel.QueueBind error : %v&quot;, err)\t\treturn\t&#125;\t// 3、消费数据\tmsg, err := rbt.channel.Consume(\t\tq.Name,         // 队列名\t\t&quot;consumerName&quot;, // 消费者的名字\t\ttrue,           // 是否自动应答\t\tfalse,          // 是否排他\t\tfalse,          // 若为true，表示 不能将同一个Conenction中生产者发送的消息传递给这个Connection中 的消费者\t\tfalse,          // 是否阻塞\t\tnil,            // 其他属性\t)\tif err != nil &#123;\t\tlog.Printf(&quot;rbt.channel.Consume error : %v&quot;, err)\t\treturn\t&#125;\tfor data := range msg &#123;\t\tlog.Printf(&quot;received data is %v&quot;, string(data.Body))\t&#125;&#125;\n// consumer.gopackage mainimport (\t&quot;log&quot;\t&quot;rabbitmq/pubsubmq&quot;)func main() &#123;\tlog.SetFlags(log.Llongfile | log.Ltime | log.Ldate)\trbt := &amp;pubsubmq.RabbitMQ&#123;\t\tExchange: &quot;PubEx&quot;,\t\tMQUrl:    &quot;amqp://guest:guest@127.0.0.1:5672/mq&quot;,\t&#125;\tpubsubmq.NewRabbitMQ(rbt)\trbt.SubscribeMsg()\tpubsubmq.RabbitMQFree(rbt)&#125;\n\n// main.gopackage mainimport (\t&quot;fmt&quot;\t&quot;log&quot;\t&quot;time&quot;\t&quot;rabbitmq/pubsubmq&quot;)/* RabbimtMQ publish 模式 案例 应用场景：邮件群发,群聊天,广播(广告) 生产消息*/func main() &#123;\tlog.SetFlags(log.Llongfile | log.Ltime | log.Ldate)\trbt := &amp;pubsubmq.RabbitMQ&#123;\t\tExchange: &quot;PubEx&quot;,\t\tMQUrl:    &quot;amqp://guest:guest@127.0.0.1:5672/mq&quot;,\t&#125;\tpubsubmq.NewRabbitMQ(rbt)\trbt.Init()\tvar index = 0\tfor &#123;\t\trbt.PublishMsg([]byte(fmt.Sprintf(&quot;hello wolrd %d &quot;, index)))\t\tlog.Println(&quot;发送成功 &quot;, index)\t\tindex++\t\ttime.Sleep(1 * time.Second)\t&#125;\tpubsubmq.RabbitMQFree(rbt)&#125;\n4. routing 路由模式\n生产者将消息发送到交换机，交换机根据路由键转发给指定的队列。消费者监听自己的队列，并从队列中取出消息\n\n目录结构：\n提前设置vhost为mq，并在其下添加交换机名为RoutingEx，类型为direct；consumer绑定监听队列到指定交换机；生产者声明交换机后发布消息，消费者声明交换机和队列后，绑定交换机和队列，而后消费消息\n//routingmq.gopackage routingmqimport (\t&quot;log&quot;\t&quot;github.com/streadway/amqp&quot;)// routing 模式// 定义 RabbitMQ 的数据结构// go get github.com/streadway/amqptype RabbitMQ struct &#123;\tconn      *amqp.Connection // 连接\tchannel   *amqp.Channel    // 通道\tQueueName string           // 队列名\tExchange  string           // 交换机\tKey       string           // 路由键\tMQUrl     string           // MQ的虚拟机地址&#125;// New 一个 RabbitMQfunc NewRabbitMQ(rbt *RabbitMQ) &#123;\tif rbt == nil || rbt.Exchange == &quot;&quot; || rbt.Key == &quot;&quot; || rbt.MQUrl == &quot;&quot; &#123;\t\tlog.Panic(&quot;please check Exchange,Key,MQUrl ...&quot;)\t&#125;\tconn, err := amqp.Dial(rbt.MQUrl)\tif err != nil &#123;\t\tlog.Panicf(&quot;amqp.Dial error : %v&quot;, err)\t&#125;\trbt.conn = conn\tchannel, err := rbt.conn.Channel()\tif err != nil &#123;\t\tlog.Panicf(&quot;rbt.conn.Channel error : %v&quot;, err)\t&#125;\trbt.channel = channel&#125;func RabbitMQFree(rbt *RabbitMQ) &#123;\tif rbt == nil &#123;\t\tlog.Print(&quot;rbt is nil,free failed&quot;)\t\treturn\t&#125;\trbt.channel.Close()\trbt.conn.Close()&#125;// 生产消息 publishfunc (rbt *RabbitMQ) ProduceRouting(data []byte) &#123;\t// 1、创建交换机\terr := rbt.channel.ExchangeDeclare(\t\trbt.Exchange,        // 交换机\t\tamqp.ExchangeDirect, // 交换机类型\t\ttrue,                // 是否持久化\t\tfalse,               // 是否自动删除\t\tfalse,               // true表示这个exchange不可以被client用来推送消息，仅用来进行exchange和exchange之间的绑定\t\tfalse,               // 是否阻塞\t\tnil,                 // 其他属性\t)\tif err != nil &#123;\t\tlog.Printf(&quot;rbt.channel.ExchangeDeclare error : %v&quot;, err)\t\treturn\t&#125;\t// 2、向队列中加入数据\terr = rbt.channel.Publish(\t\trbt.Exchange, // 交换机\t\trbt.Key,      // key\t\tfalse,        // 若为true，根据自身exchange类型和routekey规则无法找到符合条件的队列会把消息返还给发送者\t\tfalse,        // 若为true，当exchange发送消息到队列后发现队列上没有消费者，则会把消息返还给发送者\t\tamqp.Publishing&#123;\t\t\tContentType: &quot;text/plain&quot;,\t\t\tBody:        data,\t\t&#125;,\t)\tif err != nil &#123;\t\tlog.Printf(&quot;rbt.channel.Publish error : %v&quot;, err)\t\treturn\t&#125;\treturn&#125;// 消费消息func (rbt *RabbitMQ) ConsumeRoutingMsg() &#123;\t// 1、创建交换机\terr := rbt.channel.ExchangeDeclare(\t\trbt.Exchange,        // 交换机\t\tamqp.ExchangeDirect, // 交换机类型\t\ttrue,                // 是否持久化\t\tfalse,               // 是否自动删除\t\tfalse,               // true表示这个exchange不可以被client用来推送消息，仅用来进行exchange和exchange之间的绑定\t\tfalse,               // 是否阻塞\t\tnil,                 // 其他属性\t)\tif err != nil &#123;\t\tlog.Printf(&quot;rbt.channel.ExchangeDeclare error : %v&quot;, err)\t\treturn\t&#125;\t// 2、创建队列\t_, err = rbt.channel.QueueDeclare(\t\t&quot;&quot;, // 此处我们传入的是空，则是随机产生队列的名称\t\ttrue,\t\tfalse,\t\tfalse,\t\tfalse,\t\tnil,\t)\tif err != nil &#123;\t\tlog.Printf(&quot;rbt.channel.QueueDeclare error : %v&quot;, err)\t\treturn\t&#125;\t// 3、绑定队列\terr = rbt.channel.QueueBind(\t\trbt.QueueName, // 队列名字\t\trbt.Key,       // routing，这里key 需要填\t\trbt.Exchange,  // 交换机名称\t\tfalse,         // 是否阻塞\t\tnil,           // 其他属性\t)\tif err != nil &#123;\t\tlog.Printf(&quot;rbt.channel.QueueBind error : %v&quot;, err)\t\treturn\t&#125;\t// 4、消费数据\tmsg, err := rbt.channel.Consume(\t\trbt.QueueName,  // 队列名\t\t&quot;consumerName&quot;, // 消费者的名字\t\ttrue,           // 是否自动应答\t\tfalse,          // 是否排他\t\tfalse,          // 若为true，表示 不能将同一个Conenction中生产者发送的消息传递给这个Connection中 的消费者\t\tfalse,          // 是否阻塞\t\tnil,            // 其他属性\t)\tif err != nil &#123;\t\tlog.Printf(&quot;rbt.channel.Consume error : %v&quot;, err)\t\treturn\t&#125;\tfor data := range msg &#123;\t\tlog.Printf(&quot;received data is %v&quot;, string(data.Body))\t&#125;&#125;\n\n\n// consumer1.gopackage mainimport (\t&quot;log&quot;\t&quot;rabbitmq/routingmq&quot;)func main() &#123;\tlog.SetFlags(log.Llongfile | log.Ltime | log.Ldate)\trbt := &amp;routingmq.RabbitMQ&#123;\t\tExchange: &quot;RoutingEx&quot;,\t\tKey:      &quot;consumer1&quot;,\t\tMQUrl:    &quot;amqp://guest:guest@127.0.0.1:5672/mq&quot;,\t&#125;\troutingmq.NewRabbitMQ(rbt)\trbt.ConsumeRoutingMsg()\troutingmq.RabbitMQFree(rbt)&#125;\n\n// consumer2.gopackage mainimport (\t&quot;log&quot;\t&quot;rabbitmq/routingmq&quot;)func main() &#123;\tlog.SetFlags(log.Llongfile | log.Ltime | log.Ldate)\trbt := &amp;routingmq.RabbitMQ&#123;\t\tExchange: &quot;RoutingEx&quot;,\t\tKey:      &quot;consumer2&quot;,\t\tMQUrl:    &quot;amqp://guest:guest@127.0.0.1:5672/mq&quot;,\t&#125;\troutingmq.NewRabbitMQ(rbt)\trbt.ConsumeRoutingMsg()\troutingmq.RabbitMQFree(rbt)&#125;\n\n\n// main.gopackage mainimport (\t&quot;fmt&quot;\t&quot;log&quot;\t&quot;time&quot;\t&quot;rabbitmq/routingmq&quot;)/*RabbimtMQ routing 模式 案例应用场景：从系统的代码逻辑中获取对应的功能字符串,将消息任务扔到对应的队列中业务场景,例如处理错误，处理特定消息等生产消息*/func main() &#123;\tlog.SetFlags(log.Llongfile | log.Ltime | log.Ldate)\trbt1 := &amp;routingmq.RabbitMQ&#123;\t\tExchange: &quot;RoutingEx&quot;,\t\tKey:      &quot;consumer1&quot;,\t\tMQUrl:    &quot;amqp://guest:guest@127.0.0.1:5672/mq&quot;,\t&#125;\troutingmq.NewRabbitMQ(rbt1)\trbt2 := &amp;routingmq.RabbitMQ&#123;\t\tExchange: &quot;RoutingEx&quot;,\t\tKey:      &quot;consumer2&quot;,\t\tMQUrl:    &quot;amqp://guest:guest@127.0.0.1:5672/mq&quot;,\t&#125;\troutingmq.NewRabbitMQ(rbt2)\tvar index = 0\tfor &#123;\t\trbt1.ProduceRouting([]byte(fmt.Sprintf(&quot;hello wolrd consumer1  %d &quot;, index)))\t\tlog.Println(&quot;Key consumer1发送成功  &quot;, index)\t\trbt2.ProduceRouting([]byte(fmt.Sprintf(&quot;hello wolrd consumer2  %d &quot;, index)))\t\tlog.Println(&quot;Key consumer2发送成功  &quot;, index)\t\tindex++\t\ttime.Sleep(1 * time.Second)\t&#125;&#125;\n5.topic模式\n类似于routing模式，通过通配符匹配\n\n提前设置vhost为mq，并在其下添加交换机名为TopicEx，类型为topic；consumer绑定监听队列到指定交换机；生产者声明交换机后发布消息，消费者声明交换机和队列后，绑定交换机和队列，而后消费消息\n// topicmq.gopackage topicmqimport (\t&quot;log&quot;\t&quot;github.com/streadway/amqp&quot;)// topic 模式// 定义 RabbitMQ 的数据结构// go get github.com/streadway/amqptype RabbitMQ struct &#123;\tconn      *amqp.Connection // 连接\tchannel   *amqp.Channel    // 通道\tQueueName string           // 队列名\tExchange  string           // 交换机\tKey       string           // 路由键\tMQUrl     string           // MQ的虚拟机地址&#125;// New 一个 RabbitMQfunc NewRabbitMQ(rbt *RabbitMQ) &#123;\tif rbt == nil || rbt.Exchange == &quot;&quot; || rbt.Key == &quot;&quot; || rbt.MQUrl == &quot;&quot; &#123;\t\tlog.Panic(&quot;please check Exchange,Key,MQUrl ...&quot;)\t&#125;\tconn, err := amqp.Dial(rbt.MQUrl)\tif err != nil &#123;\t\tlog.Panicf(&quot;amqp.Dial error : %v&quot;, err)\t&#125;\trbt.conn = conn\tchannel, err := rbt.conn.Channel()\tif err != nil &#123;\t\tlog.Panicf(&quot;rbt.conn.Channel error : %v&quot;, err)\t&#125;\trbt.channel = channel&#125;func RabbitMQFree(rbt *RabbitMQ) &#123;\tif rbt == nil &#123;\t\tlog.Print(&quot;rbt is nil,free failed&quot;)\t\treturn\t&#125;\trbt.channel.Close()\trbt.conn.Close()&#125;// 生产消息 publishfunc (rbt *RabbitMQ) ProduceTopic(data []byte) &#123;\t// 1、创建交换机\terr := rbt.channel.ExchangeDeclare(\t\trbt.Exchange,       // 交换机\t\tamqp.ExchangeTopic, // 交换机类型\t\ttrue,               // 是否持久化\t\tfalse,              // 是否自动删除\t\tfalse,              // true表示这个exchange不可以被client用来推送消息，仅用来进行exchange和exchange之间的绑定\t\tfalse,              // 是否阻塞\t\tnil,                // 其他属性\t)\tif err != nil &#123;\t\tlog.Printf(&quot;rbt.channel.ExchangeDeclare error : %v&quot;, err)\t\treturn\t&#125;\t// 2、向队列中加入数据\terr = rbt.channel.Publish(\t\trbt.Exchange, // 交换机\t\trbt.Key,      // key\t\tfalse,        // 若为true，根据自身exchange类型和routekey规则无法找到符合条件的队列会把消息返还给发送者\t\tfalse,        // 若为true，当exchange发送消息到队列后发现队列上没有消费者，则会把消息返还给发送者\t\tamqp.Publishing&#123;\t\t\tContentType: &quot;text/plain&quot;,\t\t\tBody:        data,\t\t&#125;,\t)\tif err != nil &#123;\t\tlog.Printf(&quot;rbt.channel.Publish error : %v&quot;, err)\t\treturn\t&#125;\treturn&#125;// 消费消息func (rbt *RabbitMQ) ConsumeTopicMsg() &#123;\t// 1、创建交换机\terr := rbt.channel.ExchangeDeclare(\t\trbt.Exchange,       // 交换机\t\tamqp.ExchangeTopic, // 交换机类型\t\ttrue,               // 是否持久化\t\tfalse,              // 是否自动删除\t\tfalse,              // true表示这个exchange不可以被client用来推送消息，仅用来进行exchange和exchange之间的绑定\t\tfalse,              // 是否阻塞\t\tnil,                // 其他属性\t)\tif err != nil &#123;\t\tlog.Printf(&quot;rbt.channel.ExchangeDeclare error : %v&quot;, err)\t\treturn\t&#125;\t// 2、创建队列\t_, err = rbt.channel.QueueDeclare(\t\t&quot;&quot;, // 此处我们传入的是空，则是随机产生队列的名称\t\tfalse,\t\tfalse,\t\ttrue,\t\tfalse,\t\tnil,\t)\tif err != nil &#123;\t\tlog.Printf(&quot;rbt.channel.QueueDeclare error : %v&quot;, err)\t\treturn\t&#125;\t// 3、绑定队列\terr = rbt.channel.QueueBind(\t\trbt.QueueName, // 队列名字\t\trbt.Key,       // routing，这里key 需要填\t\trbt.Exchange,  // 交换机名称\t\tfalse,         // 是否阻塞\t\tnil,           // 其他属性\t)\tif err != nil &#123;\t\tlog.Printf(&quot;rbt.channel.QueueBind error : %v&quot;, err)\t\treturn\t&#125;\t// 4、消费数据\tmsg, err := rbt.channel.Consume(\t\trbt.QueueName,  // 队列名\t\t&quot;consumerName&quot;, // 消费者的名字\t\ttrue,           // 是否自动应答\t\tfalse,          // 是否排他\t\tfalse,          // 若为true，表示 不能将同一个Conenction中生产者发送的消息传递给这个Connection中 的消费者\t\tfalse,          // 是否阻塞\t\tnil,            // 其他属性\t)\tif err != nil &#123;\t\tlog.Printf(&quot;rbt.channel.Consume error : %v&quot;, err)\t\treturn\t&#125;\tfor data := range msg &#123;\t\tlog.Printf(&quot;received data is %v&quot;, string(data.Body))\t&#125;&#125;\n\n// consumer1.gopackage mainimport (\t&quot;log&quot;\t&quot;rabbitmq/topicmq&quot;)func main() &#123;\tlog.SetFlags(log.Llongfile | log.Ltime | log.Ldate)\trbt := &amp;topicmq.RabbitMQ&#123;\t\tExchange: &quot;TopicEx&quot;,\t\tKey:      &quot;key.*.com&quot;,\t\tMQUrl:    &quot;amqp://guest:guest@127.0.0.1:5672/mq&quot;,\t&#125;\ttopicmq.NewRabbitMQ(rbt)\trbt.ConsumeTopicMsg()\ttopicmq.RabbitMQFree(rbt)&#125;\n\n// consumer2.gopackage mainimport (\t&quot;log&quot;\t&quot;rabbitmq/topicmq&quot;)func main() &#123;\tlog.SetFlags(log.Llongfile | log.Ltime | log.Ldate)\trbt := &amp;topicmq.RabbitMQ&#123;\t\tExchange: &quot;TopicEx&quot;,\t\tKey:      &quot;key.two.com&quot;,\t\tMQUrl:    &quot;amqp://guest:guest@127.0.0.1:5672/mq&quot;,\t&#125;\ttopicmq.NewRabbitMQ(rbt)\trbt.ConsumeTopicMsg()\ttopicmq.RabbitMQFree(rbt)&#125;\n\n// main.gopackage mainimport (\t&quot;fmt&quot;\t&quot;log&quot;\t&quot;rabbitmq/topicmq&quot;\t&quot;time&quot;)/*RabbimtMQ topic 模式 案例应用场景：从系统的代码逻辑中获取对应的功能字符串,将消息任务扔到对应的队列中业务场景,例如处理错误，处理特定消息等生产消息*/func main() &#123;\tlog.SetFlags(log.Llongfile | log.Ltime | log.Ldate)\trbt1 := &amp;topicmq.RabbitMQ&#123;\t\tExchange: &quot;TopicEx&quot;,\t\tKey:      &quot;key.one.com&quot;,\t\tMQUrl:    &quot;amqp://guest:guest@127.0.0.1:5672/mq&quot;,\t&#125;\ttopicmq.NewRabbitMQ(rbt1)\trbt2 := &amp;topicmq.RabbitMQ&#123;\t\tExchange: &quot;TopicEx&quot;,\t\tKey:      &quot;key.two.com&quot;,\t\tMQUrl:    &quot;amqp://guest:guest@127.0.0.1:5672/mq&quot;,\t&#125;\ttopicmq.NewRabbitMQ(rbt2)\tvar index = 0\tfor &#123;\t\trbt1.ProduceTopic([]byte(fmt.Sprintf(&quot;hello wolrd key.one.com  %d &quot;, index)))\t\tlog.Println(&quot;Topic1发送成功  &quot;, index)\t\trbt2.ProduceTopic([]byte(fmt.Sprintf(&quot;hello wolrd key.two.com  %d &quot;, index)))\t\tlog.Println(&quot;Topic2发送成功  &quot;, index)\t\tindex++\t\ttime.Sleep(1 * time.Second)\t&#125;&#125;\n\n安装docker search rabbitmqdocker pull rabbitmqdocker run -d --hostname my-rabbit --name rabbit -p 15672:15672 -p 5673:5672 rabbitmqdocker exec -it rabbit bashrabbitmq-plugins enable rabbitmq_management","categories":["RabbitMQ"],"tags":["MQ"]},{"title":"Redis与MySQL的数据一致性问题","url":"/2023/11/26/Redis%E4%B8%8EMySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/","content":"1. Redis与MySQL的数据一致性问题\n同时向Redis和MySQL中写入数据时，由于存在网络延迟、服务器故障等问原因，导致两者之间产生数据不一致。比如用户A购买一件仅剩1件的商品，系统收到请求后，MySQL中的库存减少1，然后出现了网络延迟或系统故障，Redis中的库存没有减少，导致用户B看到商品库存还是1并下单，导致出现超卖情况。使用Redis缓存是牺牲强一致性来提高性能，即CAP中的AP，实际上保证的是最终一致性。\n\n2. 缓存读写策略\n上述问题的解决方法就是选择合适的缓存读写策略，即先更新DB还是先更新缓存等场景。·\n\n2.1 Cache-Aside Pattern（旁路缓存模式）\n服务端同时维护Cache和DB，并以DB结果为准\n\n\n读：先读缓存，读到直接返回；读不到从DB加载并写缓存，然后返回\n写：先写DB，再删缓存\n\n2.2 Write-Through Pattern（写穿透模式）\n服务端主要维护Cache，读直接读Cache；写先写Cache，而后由Cache服务同步写DB\n\n\n读：先读缓存，读到直接返回；读不到从DB加载并写缓存，然后返回\n写：先判断缓存中数据是否存在，若存在，则直接更新缓存，后续由缓存服务同步更新DB；若不存在，则直接更新DB\n\n2.3 Write-Behind Pattern（写后写模式）\nWrite-Behind Pattern与Write-Through Pattern类似，不同的是后者同步更新DB，而前者是异步批量更新DB。使用场景如消息队列异步刷盘、MySQL的InnoDB Buffer Pool机制。由于，较难保证数据一致性，因此常用于对数据一致性要求不高的场景，如播放量、点赞量等。\n\n","categories":["中间件常见使用"],"tags":["Redis与MySQL的数据一致性问题"]},{"title":"Linux命令","url":"/2023/10/22/Linux%E5%91%BD%E4%BB%A4/","content":"1.ls-l  文件详细信息-i  inode文件号-R  递归打印子目录下文件-d  不打印子目录下文件-h  以容易理解的方式打印文件大小-t  按修改时间排序输出-r  按相反顺序排序输出-a  所有文件-A  同-a，但不包括.和..-F  目录文件名后加/，可执行文件后加*\n2.cdcd - 返回上一个目录\n3.mkdir-v  创建时显示详细信息-p  递归创建目录mkdir -m 777 test   创建时设置目录权限\n4.cat-n  行号-b  省略空行cat &gt; log.txt &lt;&lt; EOF   使用heredoc来创建文件\n5.more-n  总行数+n  从第n行开始显示\n6.head-n  前n行-c  前c个字节\n7.tail-n  后n行 \n8.which&#x2F;whereiswhich 待搜索可执行文件名whereis 待搜索可执行文件名\n9.findfind 搜索路径 搜索条件-name 名称，可用正则表达式-perm 权限-type 类型-exec 对搜索结果的后续处理，结果用&#123;&#125;占位，如find . -type f -exec ls -l &#123;&#125; \\;与xargs结合使用，如find . -type f | xargs -I &#123;&#125; ls -l &#123;&#125; -maxdepth n 查询最大层数为n\n10.dfdf -h 磁盘使用情况\n11.du-c  查询结果总和-h  更可读\n12.wc-c 字节数-l 行数-m 字符数\n13.sort-r  反向排序-n  数字排序-k  指定排序字段-t  指定排序字段分隔符\n","categories":["Linux"],"tags":["Linux命令"]},{"title":"WebSocket","url":"/2023/10/23/WebSocket/","content":"\n主要针对服务器主动推送消息给客户端的场景。例如在扫码登陆这种简单场景下，HTTP1.1可采用不断轮询或长轮询的方式解决。但是在需要主动交互的全双工场景下，上述两种方式由于开销较大所以不适用，因此需要WebSocket。\n\n介绍\nWebSocket基于TCP协议，同一时间内客户端和服务器双方都可以主动向对方发送数据，即全双工通信。\n\n建立连接\n浏览器在TCP三次握手建立连接后，统一使用HTTP协议先进行一次通信。请求建立WebSocket连接的特殊请求头如下，Sec-WebSocket-Key字段是随机生成的一段 base64码：\n\nConnection: UpgradeUpgrade: WebSocketSec-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg==\\r\\n\n\n服务器响应结果如下,其中状态码101表示协议切换：\n\nHTTP/1.1 101 Switching Protocols\\r\\nSec-WebSocket-Accept: iBJKv/ALIW2DobfoA4dmr3JHBCY=\\r\\nUpgrade: WebSocket\\r\\nConnection: Upgrade\\r\\n\n\n\n服务器在收到请求后，会使用某公开算法将请求头中的Sec-WebSocket-Key转换为另一段字符串，即Sec-WebSocket-Accept。客户端收到响应后同样使用相同的公开算法进行字符串转换并比对，如果一致则通过。经过以上一来一回两次HTTP握手完成WebSocket建立。\n\n\n消息格式\noption字段\n等于1，表示text(string)类型数据包\n等于2，表示二进制类型([]byte)数据包\n等于8，表示关闭连接信号\n\npayload字段\n存放实际传输的数据长度，单位是字节，可解决TCP粘包问题。\n\n\n最开始7bit值是0～125，则表示全部数据长度，长度在0～125之间\n最开始7bit值为126，则需要额外读取7bit后16bit，即长度在126～65535之间\n最开始7bit长度为127，则需要额外读取7bit后64bit，即长度大于65535\n\npayload data字段\n实际传输的数据\n\n适用场景\n 适用于需要服务器和客户端（浏览器）频繁交互的大部分场景，比如网页&#x2F;小程序游戏，网页聊天室，以及一些类似飞书这样的网页协同办公软件。\n\n","categories":["计算机网络"],"tags":["WebSocket","HTTP"]},{"title":"Git常用命令","url":"/2023/11/14/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","content":"新建和配置git initgit config --global user.name &quot;username&quot; git config --global user.email &quot;&lt;EMAIL&gt;&quot; \n暂存区增删和提交git add . git commit -m &quot;first commit&quot;git commit -am &quot;first commit&quot;git commit --amend --no-edit\n查看信息git status              //查看当前仓库状态git status -s            //简短格式查看当前仓库状态git diff commitid                 //查看当前暂存区修改与指定提交的差异git diff branch                 //查看当前暂存区修改与指定分支的差异git log git log -n //显示最近的n条提交记录\n\n撤销git restore filename              //撤销工作区修改git reset .                         //撤销暂存区文件到工作区,与上一次commit保持一致，但工作区不变git reset --hard                  //删除暂存区文件，工作区不变git reset --hard commitid           //删除暂存区文件，工作区不变，与指定commitid保持一致git reset --soft commitid           //撤销暂存区文件到指定commitid,不重置暂存区和工作区git revert commitid                //删除指定提交内容，新生成一次提交\nstashgit stash                          //暂存当前工作区git stash list                     //查看暂存列表git stash show -p stash@&#123;0&#125;        //查看第一次暂存内容git stash apply stash@&#123;0&#125;          //恢复第一次暂存内容到工作区\n\n分支git branch                  //查看当前仓库分支git branch -a               //查看所有分支git branch -r               //查看远程分支git branch -c branchname                 //创建分支git branch -d branchname                 //删除分支git branch -m branchname newbranchname    //修改分支名git checkout branchname                   //切换分支git checkout -b branchname                //创建并切换到新分支git merge branchname                      //合并分支\n\n远程同步git remote add origin https://github.com/username/reponame git push -u origin master git pull origin master          //获取远程仓库的最新版本并合并到本地仓库 git push origin master git fetch                       //获取所有远程分支（不更新本地分支，另需merge）","categories":["Linux"],"tags":["Git命令"]},{"title":"IO多路复用","url":"/2023/10/20/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/","content":"select执行原理\n\n将当前进程的所有文件描述符（使用bitmap存储），一次性的从用户态拷贝到内核态\n在内核中快速地无差别遍历每个fd，判断是否有数据到达\n将所有fd状态，从内核态拷贝到内核态，并返回已就绪的fd个数\n在用户态遍历判断具体哪个fd已就绪，然后进行相应的事件处理\n\n\n存在的不足\n\n文件描述符为bitmap，有长度限制（1024）\nfdset无法做到重用，每次循环必须重新创建\n频繁的用户态和内核态拷贝，性能开销大\n需要对文件描述符进行遍历，时间复杂度O(n)\n\n\npollpoll结构体struct pollfd &#123;    int fd;         //文件描述符    short events;   //注册事件    short revents;  //实际发生事件，由内核填充&#125;\n执行原理\n\n将当前进程的所有文件描述符（socket连接），一次性从用户态拷贝到内核态\n在内核中快速地无差别遍历每个fd，判断是否有数据到达\n将所有fd状态，从内核态拷贝到用户态，并返回已就绪fd个数\n在用户态遍历具体哪个fd已就绪，进行对应事件处理\n\n\n存在的不足\n\npoll模型采用pollfd结构数组，解决了select的1024个文件描述符限制\n依然存在频繁的用户态和内核态间的拷贝，性能开销大\n时间复杂度为O(n)\n\n\nepoll执行原理\neventpoll结构体\n\nstruct eventpill&#123;    rdylist     已就绪事件队列    rbr         红黑树，存储文件描述符    wq          阻塞进程等待队列&#125;\n\n\nepoll_create创建eventpoll\nepoll_ctl创建epitem结构体，将包含文件描述符的epitem加入eventpoll的rbr红黑树，阻塞进程加入wq阻塞队列\nepoll_wait阻塞进程，将其加入阻塞队列\n当有数据到达时，调用回调方法，将文件描述符加入到就绪队列，并判断是否是阻塞队列进程所等待的事件\n执行后续事件\n\n\n优势\n\n在epoll_ctl()函数中，为每个文件描述符都指定回调函数，基于回调函数把就绪事件放到就绪队列中，时间复杂度降为O(1)\n只需要在epoll_ctl()时传递一次文件描述符，epoll_wait()时不需要再次传递文件描述符\nepoll基于红黑树+双链表存储，没有最大连接数限制\n\n\n","categories":["操作系统"],"tags":["IO多路复用"]},{"title":"markdown","url":"/2023/10/20/markdown/","content":"hexo new page 新文件夹hexo new post 新文件\n1.粗体**粗体**\n2.斜体*斜体*\n3.块引用&gt; 段落块一&gt; 段落块二&gt; 段落块三\n4.有序列表1. 列表项一2. 列表向二    1. 子列表项一    2. 子列表向二\n5.无序列表- 列表项一- 列表项二    - 子列表项一    - 子列表项二\n6.代码块```code```\n7.图片![测试图片加载失败描述](/2023/10/20/markdown/test.png &quot;测试图片&quot;)\n8.分隔线***\n9.链接这是一个链接 [链接名称](链接url)\n10.转义字符\\需转义字符","categories":["markdown"],"tags":["markdown"]},{"title":"MySQL表设计","url":"/2023/10/22/MySQL%E8%A1%A8%E8%AE%BE%E8%AE%A1/","content":"1. 范式与反范式1.1 数据库三范式\n1NF：原子性，列不可分2NF：满足1NF，同时列属性完全依赖于主键，不能部分依赖于主键3NF：满足2NF，同时列属性不传递依赖于非主属性，只能直接依赖于主键\n\n举例：设计符合2NF表\n\n原始表中订单编号和商品编号为联合主键，商品名称、单位、价格等信息不于主键相关，只与商品编号相关，违反了2NF,因此将原表拆分成3张表\n\n范式优点\n避免数据冗余，减少维护数据完整性的麻烦减少数据库空间数据变更速度快\n\n范式缺点\n按照范式的规范设计的表，等级越高的范式设计出来的表数量越多获取数据时，表关联过多，性能较差\n\n1.2 反范式\n针对业务场景，为减少多表关联，提高业务响应时间，允许适当的数据冗余。\n\n反范式优点\n允许适当的数据冗余，业务场景中需要的数据几乎都可以在一张表上显示，避免关联可以设计有效的索引\n\n2. 使用基本原则\n\n只用于数据存储，不进行复杂数据运算，不承载业务逻辑，确保存储和计算分离\n查询数据时尽量使用单表查询，减少跨库查询和多表关联\n杜绝大事务、大字段等性能杀手 · 大事务：运行步骤较多，涉及表和字段较多，容易造成资源争抢甚至形成死锁。事务回滚时会导致资源占用时间过长 · 大字段：blob、text等大字段尽量少使用或选择与主业务表分离，减少对该类字段的检索和更新\n\n\n3. 基本设置规则\n默认指定存储引擎为InnoDB默认字符集为UTF8mb4，支持emoji等特殊字符\n\n","categories":["MySQL"],"tags":["MySQL"]},{"title":"排序","url":"/2023/10/23/%E6%8E%92%E5%BA%8F/","content":"快速排序(不稳定)func QuickSort(nums []int, l, r int) &#123;\tif l &gt;= r &#123;\t\treturn\t&#125;\tmid := Partition(nums, l, r)\tQuickSort(nums, l, mid-1)\tQuickSort(nums, mid+1, r)&#125;func Partition(nums []int, l, r int) int &#123;\tindex := rand.Intn(r-l+1) + l\tnums[l], nums[index] = nums[index], nums[l]\tfor l &lt; r &#123;\t\tfor l &lt; r &amp;&amp; nums[l] &lt; nums[r] &#123;\t\t\tr--\t\t&#125;\t\tif l &lt; r &#123;\t\t\tnums[l], nums[r] = nums[r], nums[l]\t\t\tl++\t\t&#125;\t\tfor l &lt; r &amp;&amp; nums[l] &lt; nums[r] &#123;\t\t\tl++\t\t&#125;\t\tif l &lt; r &#123;\t\t\tnums[l], nums[r] = nums[r], nums[l]\t\t\tr--\t\t&#125;\t&#125;\treturn l&#125;\n归并排序(稳定)func sortArray(nums []int) []int &#123;\tif len(nums) &lt; 2 &#123;\t\treturn nums\t&#125;\tmid := len(nums) / 2\tleft := nums[:mid]\tright := nums[mid:]\treturn merge(sortArray(left), sortArray(right))&#125;func merge(left, right []int) []int &#123;\tvar res []int\tfor len(left) &gt; 0 &amp;&amp; len(right) &gt; 0 &#123;\t\tif left[0] &lt; right[0] &#123;\t\t\tres = append(res, left[0])\t\t\tleft = left[1:]\t\t&#125; else &#123;\t\t\tres = append(res, right[0])\t\t\tright = right[1:]\t\t&#125;\t&#125;\tif len(left) &gt; 0 &#123;\t\tres = append(res, left...)\t&#125;\tif len(right) &gt; 0 &#123;\t\tres = append(res, right...)\t&#125;\treturn res&#125;\n\n堆排序(不稳定)func Heapify(nums []int, n, i int) &#123;\tleft := 2*i + 1\tright := 2*i + 2\tlargest := i\tif left &lt; n &amp;&amp; nums[largest] &lt; nums[left] &#123;\t\tlargest = left\t&#125;\tif right &lt; n &amp;&amp; nums[largest] &lt; nums[right] &#123;\t\tlargest = right\t&#125;\tif largest != i &#123;\t\tnums[largest], nums[i] = nums[i], nums[largest]\t\tHeapify(nums, n, largest)\t&#125;&#125;func Buildheap(nums []int) &#123;\tfor i := len(nums)/2 - 1; i &gt;= 0; i-- &#123;\t\tHeapify(nums, len(nums), i)\t&#125;&#125;func HeapSort(nums []int) &#123;\tBuildheap(nums)\tfor i := len(nums) - 1; i &gt; 0; i-- &#123;\t\tnums[0], nums[i] = nums[i], nums[0]\t\tHeapify(nums, i, 0)\t&#125;&#125;","categories":["算法"],"tags":["算法","排序"]},{"title":"操作系统八股","url":"/2023/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A1/","content":"1. 用户态和内核态1.1 介绍\n\n用户态：用户态运行的程序可以直接去读用户程序的数据，拥有的权限较低。当应用程序需要执行某些特殊权限操作时，如磁盘IO、网络通信等，需要向操作系统发起系统调用请求，进入内核态。\n内核态：内核态运行的进程可以访问计算机的任何资源，包括内存空间、设备、驱动程序等，拥有较高的权限。操作系统接收到进程的系统调用请求时，会从用户态切换到内核态，执行响应的系统调用，将结果返回给用户态进程后，会从内核态切换回用户态。\n\n\n1.2 区分用户态和内核态的好处\n\n提高系统安全性，如果所有进程都能执行特权指令可能会严重影响系统运行。\n如果只有一个内核态，所有进程共享系统资源，将会导致大量的系统资源竞争和冲突，降低系统运行性能。\n\n\n1.3 切换方式\n\n系统调用(Trap):用户进程主动切换到内核态的一种方式，如磁盘IO读写，核心机制是通过一个中断实现用户态到内核态的转换，执行结束返回时再次通过中断回到用户态。\n中断:外部设备执行完相关操作后，向CPU发出中断信号，如果此时先前执行的指令是用户态指令，则需要进行切换。\n异常:如缺页异常，与中断的区别是中断来自外部，异常来自于先前执行指令的问题。\n\n\n2. 进程和线程2.1 介绍\n\n进程：程序运行的实力，系统资源分配的最小单位\n线程：轻量级进程，系统调度的基本单位。占有资源包括自身的程序计数器和本地方法栈等。\n协程：用户级线程，切换时不需要切换到内核态\n\n\n2.1.1 线程相比于进程的优势\n\n线程切换成本低，且切换时不需要切换关键的TLB\n线程更轻量，一个进程可创建多个线程，实现并发处理任务\n同一个进程内的线程可以共享内存和文件，不需要调用内核切换\n\n\n2.1.2 协程相比于线程的优势\n\n占用资源相较于线程更少\n切换时不需要陷入内核态\n\n\n2.2 进程的状态\n创建，就绪，运行，阻塞,结束\n\n2.3 进程间通信方式\n共享内存，socket套接字，管道，有名管道，共享内存，消息队列\n\n2.4 进程调度算法\n先来先服务，短作业优先，时间片轮询，多级反馈队列，优先级调度\n\n3. 死锁3.1 死锁产生的必要条件\n互斥，非抢占，不可剥夺，循环等待\n\n3.2 死锁预防\n破坏必要条件之一\n\n3.3 死锁避免\n银行家算法\n\n3.4 死锁检测\n进程资源状态图\n\n4. 内存管理虚拟内存的作用\n隔离进程，提高安全性提高内存利用率，逻辑上扩充内存空间简化内存管理，程序员不需要直接操作物理内存\n\n非连续内存管理\n段式管理：根据段号查段表，找到实际其实物理地址，加上段内偏移页式管理：根据页号查页表，找到实际其实物理地址，加上段内偏移段页式管理：先取段地址，然后页地址\n\n5. 软硬连接\n\n硬连接(ln)：硬连接和源文件inode节点号相同，删了源文件还能查看，由于inode节点号每个文件系统唯一，所以硬连接不能跨文件系统。\n软连接(ln -s)：类似快捷方式，存的是源文件路径，删了源文件无法查看。\n\n\n","categories":["操作系统"],"tags":["操作系统"]},{"title":"系统相关命令","url":"/2023/10/31/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/","content":"1.top命令1. top结果详解\n第一行，系统整体信息\n\n\n系统当前时间\n系统运行时间    \n当前登陆用户数  \n系统负载(平均队列长度)，三个数值依次表示1min，5min，15min前到现在的平均值\n\n\n第二行，进程信息\n\ntotal:    进程总数running:    正在运行的进程数sleeping:     睡眠进程数stopped:      停止的进程数zombie:       僵尸进程数\n\n第三行，CPU信息\n\nus:   用户空间占用CPU百分比sy:   内核空间占用CPU百分比ni:   用户进程空间内改变过优先级的进程占用CPU百分比id:   空闲CPU百分比wa:   等待输入输出的CPU百分比hi:   硬中断占用CPU百分比si:   软中断占用CPU百分比st:   (Steal time) 是当 hypervisor 服务另一个虚拟处理器的时候，虚拟 CPU 等待实际 CPU 的时间的百分比。\n\n第四行，内存信息\n\ntotal:    物理内存总量free:     空闲内存总量used:     使用的物理内存总量buff&#x2F;cache: 用作内核缓存的内存量\n\n第五行，交换区信息\n记录已存在内存中的交换区数据大小；内存中的内容被换出到交换区，而后又被换入内存，但使用过的交换区未被覆盖，相应的内存再次被换出时不需要再次写入。total:    交换区总量free:     空闲交换区总量used:     使用的交换区总量avail Mem:    缓冲的交换区总量\n\n进程信息区\n默认显示PID、USER、PR、NI、VIRT、RES、SHR、S、%CPU、%MEM、TIME+、COMMAND\n\nPID:进程IDPPID:父进程IDUID:进程所有者用户IDUSER:进程所有者用户名PR:进程优先级NI:nice值，负值表示高优先级，正值表示低优先级%CPU:上次更新到现在的CPU时间占用百分比TIME+:进程使用的CPU总时间%MEM:进程使用的物理内存百分比CODE:可执行代码占用物理内存的大小，单位kbDATA:可执行代码以外的部分(数据段和栈)占用的物理内存大小，单位kbRES:进程正在使用的、未被换出的物理内存大小，单位kb，RES=CODE+DATASWAP:进程使用的虚拟内存中，被换出的大小，单位kbVIRT:进程使用的虚拟内存总量，单位kb，VIRT=SWAP+RESSHR:共享内存大小，单位kbnFLT:页面错误次数nDRT:最后一次写入到现在，被修改过页面数量S:进程状态COMMAND:运行进程的命令\n2. 可用选项\n-d 后跟秒数，表示指定两次刷新的时间间隔-p 后跟进程PID，查询指定进程信息-b 批处理，输出内容到文件时需要-n 指定刷新次数\n\n举例：每2.5秒刷新一次top内容，总计5次，并将结束输出到top.txt文件top -b -d 2.5 -n 5 &gt; top.txt\n\nP:对%CPU列排序M:对%MEM列排序T:对TIME+列排序R:逆序f:显示或隐藏列\n\n2.free命令-b              输出以字节为单位    -k              输出以KB为单位-m              输出以MB为单位-g              输出以GB为单位-s 间隔时间      按指定间隔时间输出-t              显示总计\n\n\ntotal:物理内存总计used:已使用free:空闲shared:不同进程共享内存buff&#x2F;cache:缓存available:可用内存总计\n\n3. netstat命令-a  显示全部端口-t  显示tcp端口-u  显示udp端口-n  直接显示IP地址，而不通过域名服务器-p  显示进程号和名称-l  显示监听端口-r  显示路由表-e  显示扩展信息，如uid-s  按协议显示统计信息\n举例netstat -atnp   //显示所有tcp端口netstat -aunp   //显示所有udp端口端口netstat -l      //显示所有监听端口\n4. ps命令举例一:按CPU资源的使用量进行排序输出ps aux | sort -rnk 3\n举例二:按内存资源的使用量进行排序输出ps aux | sort -rnk 4\n举例三:显示所有进程信息ps -ef","categories":["Linux"],"tags":["Linux命令","系统相关命令"]}]